const data = {
    install : {
        text1 : 'Create React App არის კომფორტული გარემო React-ის შესასწავლად და ერთერთი გზა React-ში ახალი, ერთგვერდიანი აპლიკაციის შესაქმნელად.',
        text2 : 'ის ქმნის სამუშაო გარემოს ისე, რომ თქვენ შეგიძლიათ გამოიყენოთ JavaScript-ის უახლესი ფუნქციები, უზრუნველყოფს დეველოპერის სასიამოვნო გამოცდილებას React-თან მუშაობისას და ოპტიმიზაციას უკეთებს თქვენს აპლიკაციას. თქვენს კომპიუტერში უნდა გქონდეთ  დაინსტალირებული  ',
        text3 : ' Node >= 14.0.0 და npm >= 5.6.',
        text4 : ' პროექტის შესაქმნელად, ტერმინალში გაუშვით შემდეგი ბრძანებები:',
        text5 : 'პირველ სტრიქონზე npx არ გეგონოთ შეცდომა — ეს არის პაკეტების გაშვების ინსტრუმენტი, რომელიც npm-ში გაჩნდა 5.2+ ვერსიიდან.',
        text6 : 'Create React App არ ამუშავებს backend-ის და მონაცემთა ბაზების ლოგიკას; ის ქმნის frontend-იდან მონაცემების გამტარს, რომლებიც შემდეგ თქვენ შეგიძლიათ გამოიყენოთ ნებისმიერ backend ტექნოლოგიაში. Create React App იყენებს ',
        text7 : ' თუმცა ამ ეტაპზე თქვენ არ გჭირდებათ მათ შესახებ სიღრმისეული ცოდნა.',
        text8 : 'როდესაც თქვენი აპლიკაცია მზად იქნება,  ტერმინალში უნდა გაშვათ npm run build ბრძანება, რომელიც თქვენს პროექტში ახალ build საქაღალდეში შექმნის აპლიკაციის ოპტიმიზებულ კონსტრუქციას.'
    },
    article1 : {
        text1 : 'React-ის აპლიკაციის ყველაზე მცირე მაგალითი ასე გამოიყურება:',
        text2 : 'ვებ გვერდზე გამოჩნდება წარწერა:  “Hello, world!”',
        text3 : 'დააჭირეთ ზემოთ მოცემულ ბმულს კოდის ონლაინ რედაქტორის გასახსნელად. თავისუფლად შეიტანეთ კოდში ცვლილებები და ნახეთ, როგორ იმოქმედებს ისინი მიღებულ შედეგზე. ამ სახელმძღვანელოს გვერდების უმეტესობას ექნება მსგავსი რედაქტირებადი მაგალითები.',
        text4 : 'როგორ გამოვიყენოთ ეს სახელმძღვანელო',
        text5 : 'ამ სახელმძღვანელოში ჩვენ განვიხილავთ React-ის აპლიკაციების სამშენებლო ბლოკებს: ელემენტებს და კომპონენტებს. მას შემდეგ რაც მათ დაეუფლებით,  შეგეძლებათ შექმნათ რთული აპლიკაციები მცირე, მრავალჯერადი გამოყენების ნაწილებისგან.',
        text6 : 'ეს სახელმძღვანელო განკუთვნილია მათთვის, ვინც უპირატესობას ანიჭებს React-ის კონცეპციების სწავლას ეტაპობრივად, ნაბიჯ-ნაბიჯ.',
        text7 : 'სახელმძღვანელოს პირველ ნაწილში განხილულია React-ის ძირითადი კონცეფციები. სხვა განყოფილებების სია თქვენ შეგიძლიათ ნახოთ ნავიგაციის პანელში, მარჯვენა გვერდითა ზოლში.',
        text8 : 'სახელმძღვანელოს ყოველი ნაწილი ეფუძვნება წინა ნაწილებში გავლილ მასალას. თქვენ შეგიძლიათ გაეცნოთ React-ის მთავარ ნაწილს „ძირითადი კონცეფციების“  თავის გავლით და შემდეგ გაყვეთ თავებს იმ თანმიმდევრობით, როგორც ისინი არიან დალაგებული ნავიგაციის პანელში. მაგალითად, შემდეგი თავი არის  - "JSX-თან გაცნობა".',
        text9 : 'React – JavaScript-ის ბიბლიოთეკაა, ამიტომ ამ სახელმძღვანელოს გასავლელად თქვენ გჭირდებათ JavaScript ენის საბაზისო ცოდნა. თუკი თქვენ ვერ გძნობთ საკმარის თავდაჯერებულობას JavaScript-ში, გირჩევთ საკუთარი ცოდნის გასაახლებლად გაეცნოთ მითითებულ ბმულზე განთავსებულ '        
    },
    article2 : {
        text1 : 'განვიხილოთ ცვლადის გამოცხადების მაგალითი:',
        text2 : 'დამეთანხმებით, უცნაური სინტაქსია JavaScript-ისთვის - თითქოს არც სტრინგია და HTML-ის ფრაგმენტსაც წააგავს.',
        text3 : 'ეს არის JSX - JavaScript ენის გაფართოება. ჩვენ ვიყენებთ მას React-ში სამომხმარებლო ინტერფეისის (UI) შესაქმნელად.  JSX ძალიან წააგავს HTML მარქაფის ენას, თუმცა დამატებით ის ფლობს JavaScript-ის მთელ ძალას.  JSX-ის დახმარებით  იქმნება React-ის «ელემენტები». ',
        text4 : 'React-ის მთავარი პრინციპი მდგომარებს იმაში,  რომ რენდერინგის ლოგიკა განუყოფელია UI-ს სხვა ლოგიკებისგან, მაგალითად, როგორ იმართება event-ები, როგორ იცვლება დროში state და როგორ მზადდება მონაცემები ვებ გვერდზე გამოსატანად.',
        text5 : 'იმის ნაცვლად რომ მარქაფი და ფუნქციური ლოგიკა ხელოვნურად დავყოთ სხვადასხვა ფაილებში, React-ი უბრალოდ ანაწილებს პასაუხისმგებლობებს ურთიერთდაკავშირებული ელემენტების საშუალებით,  რომლებსაც ქვიათ «კომპონენტები». კომპონენტები შეიცავენ ერთდროულად მარქაფსაც და ლოგიკასაც.',
        text6 : 'ქვემოთ მოცემულ მაგალითში გამოვაცხადებთ name ცვლადს, რომელსაც შემდეგ ჩავსვამთ  JSX-ში, ფიგურული ფრჩხილების გამოყენებით:',
        text7 : 'JSX-ში ფიგურული ფრჩხილების შიგნით შესაძლებელია გამოვიყენოთ JavaScript-ში დასაშვები ნებისმიერი გამოსახულება. მაგალითად, 2 + 2, user.firstName და formatName(user).',
        text8 : 'ქვემოთ მოცემულ მაგალითში formatName(user) ფუნქციისგან მიღებულ შედეგს ვსვამთ  <h1> ელემენტში:',
        text9 : 'კომპილაციის შემდეგ ხდება ყველა JSX-გამოსახულების ისევე გამოძახება, როგორც ჩვეულებრივ JavaScript ფუნქციის, რომლის შედეგიც  - JavaScript ობიექტია. აქედან გამომდინარე JSX-ის გამოყენება შესაძლებელია if ინსტრუქციებში , for ციკლებში, შეგვიძლია ცვლადში შევინახოთ როგორც მნიშვნელობა, გადავცეთ ფუნქციას არგუმენტის სახით და ასევე დავაბრუნოთ ფუნქციიდან.',
        text10 : 'ელემენტის ატრიბუტებზე ტექსტური მნიშვნელობის მისანიჭებლად გამოიყენება ბრჭყალები:',
        text11 : 'თუკი ატრიბუტის მნიშვნელობაში გვჭირდება JavaScript-გამოსახულების მითითითება, ასეთ შემთხვევაში ვიყენებთ ფიგურულ ფრჩხილებს:',
        text12 : 'არ შეიძლება ბრჭყალების გამოყენება ფიგურული ფრჩხილების გარეთ, როცა ატრიბუტის მნიშვნელობად იყენებთ JavaScript-გამოსახულებებს. უნდა გამოვიყენოთ ცალცალკე -  ბრჭყალები (ტექსტური მნიშვნელობების დროს) ან ფიგურული ფრჩხილები (JavaScript-ის გამოსახულებების დროს), ოღონდ არა ერთად.',
        text13 : 'იმის გამო რომ JSX უფრო ახლოსაა  JavaScript-თან ვიდრე HTML-თან, React DOM-ი  ატრიბუტის სახელების შექმნისას, ჩვეულებრივი HTML ატრიბუტებისგან განსხვავებით, იყენებს camelCase ვარიანტს. მაგალითად,  ატრიბუტი class JSX-ში ხდება className , ხოლო tabindex - tabIndex.',
        text14 : 'ცარიელი, კონტენტის გარეშე ტეგი შეგვიძლია მაშინვე დავხუროთ /> გამოყენეით, ისევე როგორც  XML-ში:',
        text15 : 'JSX-ტეგები ასევე შესაძლებელია შეიცავდეს შვილობილ ელემენტებსაც:',
        text16 : 'მომხმარებლის მიერ შეყვანილი მონაცემები უსაფრთხოდ შეგვიძლია გამოვიყენოთ  JSX-ში:',
        text17 : 'ჩვეულებრივ  React DOM-ი გვერდს უვლის ყველა მონაცემს, რომელიც მოთავსებულია JSX-ში მანამდე, სანამ მოხდება რენდერი. ეს გამორიცხავს ყველა იმ მონაცემის მოხვედრას აპლიკაციაში, რაც არ იყო წინასწარ გაწერილი. ყველა მონაცემი საბოლოო ჯამში რენდერამდე გარდაიქმნება ტექსტურ ფორმატში, რაც გვეხმარება XSS (cross-site-scripting)  შეტევებისგან თავის არიდებაში.',
        text18 : 'Babel-ი აკომპილირებს JSX-ს  React.createElement() ფუნქციის გამოძახებით.',
        text19 : 'შემდეგი ორი მაგალითი ერთმანეთის ექვივალენტურია:',
        text20 : 'React.createElement() ფუნქცია ამოწმებს შეცდომებს კოდში და ამასთან ერთად, რაც მთავარია -  ქმნის მსგავს ობიექტს:',
        text21 : 'ამ ობიექტებს ქვიათ React-ელემენტები. შეიძლება ითქვას რომ, ისინი გამოსახავენ შედეგს, რომლის ნახვაც ჩვენ გვინდა ეკრანზე. React-ი კითხულობს ამ ობიექტებს და იყენებს მათ DOM-ის სტრუქტურის კონსტრუირებისთვის ან განახლებისთვის.',
        




    }
}

export default data