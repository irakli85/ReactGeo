const data = {
    install : {
        text1 : 'Create React App არის კომფორტული გარემო React-ის შესასწავლად და ერთერთი გზა React-ში ახალი, ერთგვერდიანი აპლიკაციის შესაქმნელად.',
        text2 : 'ის ქმნის სამუშაო გარემოს ისე, რომ თქვენ შეგიძლიათ გამოიყენოთ JavaScript-ის უახლესი ფუნქციები, უზრუნველყოფს დეველოპერის სასიამოვნო გამოცდილებას React-თან მუშაობისას და ოპტიმიზაციას უკეთებს თქვენს აპლიკაციას. თქვენს კომპიუტერში უნდა გქონდეთ  დაინსტალირებული  ',
        text3 : ' Node >= 14.0.0 და npm >= 5.6.',
        text4 : ' პროექტის შესაქმნელად, ტერმინალში გაუშვით შემდეგი ბრძანებები:',
        text5 : 'პირველ სტრიქონზე npx არ გეგონოთ შეცდომა — ეს არის პაკეტების გაშვების ინსტრუმენტი, რომელიც npm-ში გაჩნდა 5.2+ ვერსიიდან.',
        text6 : 'Create React App არ ამუშავებს backend-ის და მონაცემთა ბაზების ლოგიკას; ის ქმნის frontend-იდან მონაცემების გამტარს, რომლებიც შემდეგ თქვენ შეგიძლიათ გამოიყენოთ ნებისმიერ backend ტექნოლოგიაში. Create React App იყენებს ',
        text7 : ' თუმცა ამ ეტაპზე თქვენ არ გჭირდებათ მათ შესახებ სიღრმისეული ცოდნა.',
        text8 : 'როდესაც თქვენი აპლიკაცია მზად იქნება,  ტერმინალში უნდა გაშვათ npm run build ბრძანება, რომელიც თქვენს პროექტში ახალ build საქაღალდეში შექმნის აპლიკაციის ოპტიმიზებულ კონსტრუქციას.'
    },
    article1 : {
        text1 : 'React-ის აპლიკაციის ყველაზე მცირე მაგალითი ასე გამოიყურება:',
        text2 : 'ვებ გვერდზე გამოჩნდება წარწერა:  “Hello, world!”',
        text3 : 'დააჭირეთ ზემოთ მოცემულ ბმულს კოდის ონლაინ რედაქტორის გასახსნელად. თავისუფლად შეიტანეთ კოდში ცვლილებები და ნახეთ, როგორ იმოქმედებს ისინი მიღებულ შედეგზე. ამ სახელმძღვანელოს გვერდების უმეტესობას ექნება მსგავსი რედაქტირებადი მაგალითები.',
        text4 : 'როგორ გამოვიყენოთ ეს სახელმძღვანელო',
        text5 : 'ამ სახელმძღვანელოში ჩვენ განვიხილავთ React-ის აპლიკაციების სამშენებლო ბლოკებს: ელემენტებს და კომპონენტებს. მას შემდეგ რაც მათ დაეუფლებით,  შეგეძლებათ შექმნათ რთული აპლიკაციები მცირე, მრავალჯერადი გამოყენების ნაწილებისგან.',
        text6 : 'ეს სახელმძღვანელო განკუთვნილია მათთვის, ვინც უპირატესობას ანიჭებს React-ის კონცეპციების სწავლას ეტაპობრივად, ნაბიჯ-ნაბიჯ.',
        text7 : 'სახელმძღვანელოს პირველ ნაწილში განხილულია React-ის ძირითადი კონცეფციები. სხვა განყოფილებების სია თქვენ შეგიძლიათ ნახოთ ნავიგაციის პანელში, მარჯვენა გვერდითა ზოლში.',
        text8 : 'სახელმძღვანელოს ყოველი ნაწილი ეფუძვნება წინა ნაწილებში გავლილ მასალას. თქვენ შეგიძლიათ გაეცნოთ React-ის მთავარ ნაწილს „ძირითადი კონცეფციების“  თავის გავლით და შემდეგ გაყვეთ თავებს იმ თანმიმდევრობით, როგორც ისინი არიან დალაგებული ნავიგაციის პანელში. მაგალითად, შემდეგი თავი არის  - "JSX-თან გაცნობა".',
        text9 : 'React – JavaScript-ის ბიბლიოთეკაა, ამიტომ ამ სახელმძღვანელოს გასავლელად თქვენ გჭირდებათ JavaScript ენის საბაზისო ცოდნა. თუკი თქვენ ვერ გძნობთ საკმარის თავდაჯერებულობას JavaScript-ში, გირჩევთ საკუთარი ცოდნის გასაახლებლად გაეცნოთ მითითებულ ბმულზე განთავსებულ '        
    },
    article2 : {
        text1 : 'განვიხილოთ ცვლადის გამოცხადების მაგალითი:',
        text2 : 'დამეთანხმებით, უცნაური სინტაქსია JavaScript-ისთვის - თითქოს არც სტრინგია და HTML-ის ფრაგმენტსაც წააგავს.',
        text3 : 'ეს არის JSX - JavaScript ენის გაფართოება. ჩვენ ვიყენებთ მას React-ში სამომხმარებლო ინტერფეისის (UI) შესაქმნელად.  JSX ძალიან წააგავს HTML მარქაფის ენას, თუმცა დამატებით ის ფლობს JavaScript-ის მთელ ძალას.  JSX-ის დახმარებით  იქმნება React-ის «ელემენტები». ',
        text4 : 'React-ის მთავარი პრინციპი მდგომარებს იმაში,  რომ რენდერინგის ლოგიკა განუყოფელია UI-ს სხვა ლოგიკებისგან, მაგალითად, როგორ იმართება event-ები, როგორ იცვლება დროში state და როგორ მზადდება მონაცემები ვებ გვერდზე გამოსატანად.',
        text5 : 'იმის ნაცვლად რომ მარქაფი და ფუნქციური ლოგიკა ხელოვნურად დავყოთ სხვადასხვა ფაილებში, React-ი უბრალოდ ანაწილებს პასაუხისმგებლობებს ურთიერთდაკავშირებული ელემენტების საშუალებით,  რომლებსაც ქვიათ «კომპონენტები». კომპონენტები შეიცავენ ერთდროულად მარქაფსაც და ლოგიკასაც.',
        text6 : 'ქვემოთ მოცემულ მაგალითში გამოვაცხადებთ name ცვლადს, რომელსაც შემდეგ ჩავსვამთ  JSX-ში, ფიგურული ფრჩხილების გამოყენებით:',
        text7 : 'JSX-ში ფიგურული ფრჩხილების შიგნით შესაძლებელია გამოვიყენოთ JavaScript-ში დასაშვები ნებისმიერი გამოსახულება. მაგალითად, 2 + 2, user.firstName და formatName(user).',
        text8 : 'ქვემოთ მოცემულ მაგალითში formatName(user) ფუნქციისგან მიღებულ შედეგს ვსვამთ  <h1> ელემენტში:',
        text9 : 'კომპილაციის შემდეგ ხდება ყველა JSX-გამოსახულების ისევე გამოძახება, როგორც ჩვეულებრივ JavaScript ფუნქციის, რომლის შედეგიც  - JavaScript ობიექტია. აქედან გამომდინარე JSX-ის გამოყენება შესაძლებელია if ინსტრუქციებში , for ციკლებში, შეგვიძლია ცვლადში შევინახოთ როგორც მნიშვნელობა, გადავცეთ ფუნქციას არგუმენტის სახით და ასევე დავაბრუნოთ ფუნქციიდან.',
        text10 : 'ელემენტის ატრიბუტებზე ტექსტური მნიშვნელობის მისანიჭებლად გამოიყენება ბრჭყალები:',
        text11 : 'თუკი ატრიბუტის მნიშვნელობაში გვჭირდება JavaScript-გამოსახულების მითითითება, ასეთ შემთხვევაში ვიყენებთ ფიგურულ ფრჩხილებს:',
        text12 : 'არ შეიძლება ბრჭყალების გამოყენება ფიგურული ფრჩხილების გარეთ, როცა ატრიბუტის მნიშვნელობად იყენებთ JavaScript-გამოსახულებებს. უნდა გამოვიყენოთ ცალცალკე -  ბრჭყალები (ტექსტური მნიშვნელობების დროს) ან ფიგურული ფრჩხილები (JavaScript-ის გამოსახულებების დროს), ოღონდ არა ერთად.',
        text13 : 'იმის გამო რომ JSX უფრო ახლოსაა  JavaScript-თან ვიდრე HTML-თან, React DOM-ი  ატრიბუტის სახელების შექმნისას, ჩვეულებრივი HTML ატრიბუტებისგან განსხვავებით, იყენებს camelCase ვარიანტს. მაგალითად,  ატრიბუტი class JSX-ში ხდება className , ხოლო tabindex - tabIndex.',
        text14 : 'ცარიელი, კონტენტის გარეშე ტეგი შეგვიძლია მაშინვე დავხუროთ /> გამოყენებით, ისევე როგორც  XML-ში:',
        text15 : 'JSX-ტეგები ასევე შესაძლებელია შეიცავდეს შვილობილ ელემენტებსაც:',
        text16 : 'მომხმარებლის მიერ შეყვანილი მონაცემები უსაფრთხოდ შეგვიძლია გამოვიყენოთ  JSX-ში:',
        text17 : 'ჩვეულებრივ  React DOM-ი გვერდს უვლის ყველა მონაცემს, რომელიც მოთავსებულია JSX-ში მანამდე, სანამ მოხდება რენდერი. ეს გამორიცხავს ყველა იმ მონაცემის მოხვედრას აპლიკაციაში, რაც არ იყო წინასწარ გაწერილი. ყველა მონაცემი საბოლოო ჯამში რენდერამდე გარდაიქმნება ტექსტურ ფორმატში, რაც გვეხმარება XSS (cross-site-scripting)  შეტევებისგან თავის არიდებაში.',
        text18 : 'Babel-ი აკომპილირებს JSX-ს  React.createElement() ფუნქციის გამოძახებით.',
        text19 : 'შემდეგი ორი მაგალითი ერთმანეთის ექვივალენტურია:',
        text20 : 'React.createElement() ფუნქცია ამოწმებს შეცდომებს კოდში და ამასთან ერთად, რაც მთავარია -  ქმნის მსგავს ობიექტს:',
        text21 : 'ამ ობიექტებს ქვიათ React-ელემენტები. შეიძლება ითქვას რომ, ისინი გამოსახავენ შედეგს, რომლის ნახვაც ჩვენ გვინდა ეკრანზე. React-ი კითხულობს ამ ობიექტებს და იყენებს მათ DOM-ის სტრუქტურის კონსტრუირებისთვის ან განახლებისთვის.'
    },
    article3 : {
        text1 : 'ელემენტები React აპლიკაციის ყველაზე პატარა სამშენებლო ბლოკებია.',
        text2 : 'ელემენტები აღწერენ იმას, თუ რისი ნახვაც გსურთ ეკრანზე:',
        text3 : 'ბრაუზერის DOM ელემენტებისგან განსხვავებით, React-ის ელემენტები უბრალო ობიექტებია და შესაბამისად მეხსიერების მცირე რესურს მოითხოვს მათი შექმნა. React DOM ზრუნავს ბრაუზერის DOM-ის განახლებაზე, რათა ის შეესაბამებოდეს React-ის ელემენტებს.',
        text4 : 'ნუ ავურევთ ერთმანეთში "ელემენტებს" და უფრო ფართოდ ცნობილ კონცეფციას - "კომპონენტებს". ელემენტები არის ის, რისგანაც შედგება კომპონენტები. ჩვენ განვიხილავთ კომპონენტებს ამ სახელმძღვანელოს მომდევნო ნაწილში.',
        text5 : 'მაგალითად, HTML ფაილში გვაქვს  <div> ტეგი:',
        text6 : 'React-ის აპლიკაციებისთვის ეს არის "ძირითადი", "root" DOM ​​კვანძი, რადგან React DOM მართვას მხოლოდ ამ კვანძში მიმდინარე ყველა პროცესს.',
        text7 : 'React-ის საშუალებით შექმნილ აპლიკაციებს ჩვეულებრივ აქვთ ერთი root DOM კვანძი. თუ ინტეგრაციას უკეთებთ React-ს უკვე არსებულ სხვა აპლიკაციაში, მაშინ თქვენ შეიძლება გქონდეთ იმდენი იზოლირებული root DOM კვანძი, რამდენიც გსურთ.',
        text8 : 'React-ელემენტის რენდერისთვის, ჯერ  DOM-ელემენტი  გადაეცემა  ReactDOM.createRoot() ფუნქციას, ხოლო შემდეგ React-ელემენტი  root.render() ფუნქციას:',
        text9 : 'ვებ-გვერდზე გამოვა ტექსტი  «Hello, world».',
        text10 : 'React-ის ელემენტები უცვლელია (immutable). მათი შექმნის შემდეგ, პირდაპირი გზით თქვენ ვეღარ შეცვლით მის შვილობილ ელემენტებს ან ატრიბუტებს. ელემენტი ჰგავს ერთ შეჩერებულ კადრს ფილმიდან: ის წარმოადგენს სტატიკურ UI-ს დროის გარკვეულ მომენტში.',
        text11 : 'ჯერჯერობით, React-ის იმ ცოდნით, რომელიც ამ ეტაპზე გვაქვს, UI-ს განახლების ერთადერთი გზა არის ახალი ელემენტის შექმნა და მისი გადაცემა root.render() ფუნქციაზე.',
        text12 : 'განვიხილოთ მაგალითი:',
        text13 : 'ამ მაგალითში root.render() ფუნქცია გამოიძახება ყოველ წამში  setInterval() ფუნქციის გამოყენებით.',
        text14 : 'პრაქტიკაში, უმრავლესობა React-აპლიკაციებში root.render() ფუნქცია გამოიძახება მხოლოდ ერთხელ. შემდეგში ჩვენ განვიხილავთ, თუ როგორ ხდება  UI-ს განახლება state-ის მეშვეობით.',
        text15 : 'React-ი ანახლებს მხოლოდ იმ ელემენტებს, რომელიც საჭიროა',
        text16 : 'React DOM-ი ადარებს მთავარ და მის შვილობილ ელემენტებს წინა ვერსიებს და DOM-ში შეაქვს მხოლოდ მინიმალური საჭირო განახლებები, DOM-ის სასურველ მდგომარეობამდე მისაყვანად.',
        text17 : 'ბოლო მაგალითის ბრაუზერში გადამოწმებით ადვილად შეგიძლიათ დარწმუნდეთ ამაში:',
        text18 : 'მიუხედავად იმისა, რომ ჩვენი შექმნილი ელემენტი შეიცავს აპლიკაციის მთელ  UI-ხეს, React DOM-ი ყოველ წამში ანახლებს ტექსტური კონტენტის მხოლოდ იმ ნაწილს , რომელიც იცვლება.'
    },
    article4 : {
        text1 : 'React აპლიკაციები აგებულია UI-ის იზოლირებული ნაწილებისგან, რომლებსაც ეწოდება კომპონენტები. React-ის კომპონენტი - ეს არის JavaScript-ის ფუნქცია, რომელშიც შეგვიძლია ვწეროთ მარქაფი. კომპონენტი შეიძლება იყოს ისეთივე პატარა, როგორც ღილაკი, ან ისეთივე დიდი, როგორც მთელი ვებ-გვერდი. მაგალითში მოცემულია  Gallery კომპონენტი, რომელიც შეიცავს სამ Profile კომპონენტს:',
        text2 : 'ტრადიციულად, ვებ გვერდების შექმნის დროს დეველოპერები ჯერ აკეთებდნენ კონტენტის მარქაფს, რომელსაც მერე JavaScript-ის საშუალებით აძლევდნენ ინტერაქტიულობას. React-ი ინტერაქტიულობას აყენებს პირველა ადგილზე.',
        text3 : 'export default სტანდარტული JavaScript მოდულების სინტაქსია. ის საშუალებას გაძლევთ ფაილში მონიშნოთ ძირითადი ფუნქცია, რათა მოგვიანებით შეძლოთ სხვა ფაილებში მისი იმპორტი.',
        text4 : 'function Profile() { } მეშვეობით  განსაზღვრულია JavaScript ფუნქცია სახელით Profile.',
        text5 : 'React კომპონენტები ჩვეულებრივი JavaScript ფუნქციებია, მაგრამ მათი სახელები უნდა დაიწყოს დიდი ასოებით, წინააღმდეგ შემთხვევაში ისინი არ იმუშავებენ!',
        text6 : 'Profile კომპონენტი აბრუნებს <img/> ტეგს, რომელსაც აქვს  src და alt ატრიბუტები. ტეგები იწერება იმავე სინტაქსით, როგორც HTML-ში, მაგრამ ის რეალურად JavaScript-ია! ამ სინტაქსს ეწოდება JSX და ის საშუალებას გაძლევთ ჩასვათ მარქაფი JavaScript-ში.',
        text7 : 'return-ის მნიშვნელობები უნდა დაიწეროს  ერთ ხაზზე, როგორც ამ კომპონენტში:',
        text8 : 'მაგრამ თუ თქვენი მარქაფი არ არის ერთ  ხაზზე, მაშინ return-ის შემდეგ ისინი უნდა მოთავსდნენ ფრჩხილებში:',
        text9 : 'ფრჩხილების გარეშე return-ის შემდეგ ყველა კოდი იგნორირებული იქნება!',
        text10 : 'ეხლა როცა თქვენ უკვე შექმენით  Profile კომპონენტი, შეგიძლიათ ის მოათავსოთ სხვა კომპონენტებში. მაგალითად, თქვენ შეგიძლიათ გააექსპორტოთ Gallery კომპონენტი, რომელიც იყენებს რამოდენიმე Profile კომპონენტს:',
        text11 : '<section> დაწერილია დაბალ რეგისტრში , ამიტომ React-მა იცის, რომ ჩვენ ამ შემთხვევაში ვიყენებთ HTML ტეგს.',
        text12 : '<Profile /> იწყება მაღალი რეგისტრის P ასოთი, ამიტომ, React-მა იცის, რომ ჩვენ ვიყენებთ Profile კომპონენტს.',
        text13 : 'Profile კომპონენტი თავად შეიცავს HTML-ს <img /> ტეგის სახით. საბოლოო ჯამში,  ბრაუზერი ხედავს ასეთ სტრუქტურას:',
        text14 : 'კომპონენტები ჩვეულებრივი JavaScript ფუნქციებია, ასე რომ თქვენ შეგიძლიათ შეინახოთ რამდენიმე კომპონენტი ერთ ფაილში. ეს მოსახერხებელია, მაშინ როდესაც კომპონენტები შედარებით მცირეა ან ერთმანეთთან მჭიდრო კავშირშია. თუ ერთ ფაილში ბევრი კომპონენტი დაგიგროვდათ, ყოველთვის შეგიძლიათ გადაიტანოთ ისინი ცალკე ფაილში.',
        text15 : 'რადგანაც Profile კომპონენტები მოთავსებული არიან Gallery კომპონენტის შიგნით  შეგვიძლია ვთქვათ, რომ Gallery არის მშობელი კომპონენტი, Profile კი შვილობილი კომპონენტი. ეს არის React-ის მაგიის ნაწილი: თქვენ შეგიძლიათ განსაზღვროთ კომპონენტი ერთხელ და შემდეგ გამოიყენოთ ის იმდენ ადგილას და იმდენჯერ, რამდენჯერაც გსურთ.',
        text16 : 'კომპონენტები შეიძლება შეიცავდეს  სხვა კომპონენტებს, თუმცა არ შეიძლება კომპონენტში სხვა კომპონენტის შექმნა:',
        text17 : 'ზემოთ მოყვანილი კოდის ფრაგმენტი ძალიან ნელია და იწვევს შეცდომებს. ამის ნაცვლად, განსაზღვრეთ ყველა კომპონენტი  ცალ-ცალკე, ზედა დონეზე:',
        text18 : 'React გაძლევთ საშუალებას შექმნათ კომპონენტები - მრავაჯერადად გამოყენებადი UI ელემენტები თქვენი აპლიკაციისთვის.',
        text19 : 'React-ის აპლიკაციაში ინტერფეისის თითოეული ნაწილი არის კომპონენტი.',
        text20 : 'React-ის კომპონენტები ჩვეულებრივი JavaScript ფუნქციებია, იმ განსხვავებით, რომ :',
        text21 : '1. მათი სახელები ყოველთვის დიდი ასოებით იწყება.',
        text22 : '2. ისინი აბრუნებენ JSX მარქაფს.'
    },
    article5 : {
        text1 : 'კომპონენტების მაგია მდგომარეობს მათი მრავალჯერადი  გამოყენების შესაძლებლობაში: თქვენ შეგიძლიათ შექმნათ კომპონენტები, რომლებიც შედგება სხვა კომპონენტებისგან. მაგრამ რაც უფრო და უფრო მეტ კომპონენტს ქმნით ერთ ფაილში, ხშირად უფრო მოსახერხებელია  მათი სხვადასხვა ფაილებად დაყოფა. ეს საშუალებას გაძლევთ მარტივად მისაგნები იყოს კომპონენტები და მათი ხელახლა გამოყენება სხვადასხვა  ადგილას.',
        text2 : 'ეს კომპონენტები მოთავსებულია მთავარ კომპონენტში, რომელსაც ქვია App.js.  ამ მაგალითში,  Create React App-ით შექმნილი თქვენი აპლიკაცია ცხოვრობს src/App.js ფაილში. React აპლიკაციის შექმნის მეთოდიდან გამომდინარე მთავარი კომპონენტი შეიძლება იყოს სხვა ფაილშიც.',
        text3 : 'როგორ უნდა მოვიქცეთ თუკი უკვე არსებული Gallery და Profile  კომპონენტების გამოყენება გვინდა სხვა ფაილში ან სულაც სხვა პროექტში?  ამისათვის კომპონენტები  უნდა გავიტანოთ ძირითადი ფაილიდან. ამით ისინი გახდებიან უფრო მოდულარულები და საშუალება გვექნება მრავალჯერადად გამოვიყენოთ სხვა ფაილებშიც. ამისათვის საჭიროა შემდეგი 3 ნაბიჯის გავლა:',
        text4 : 'შექმენით ახალი JS ფაილი, რომელშიც განვათავსებთ კომპონენტს.',
        text5 : 'დააექსპორტეთ კომპონენტი ამ ფაილიდან default ან named export-ის გამოყენებით.',
        text6 : 'დააიმპორტეთ კომპონენტი იმ ფაილში, სადაც გსურთ მისი გამოყენება default ან named import-ის შესაბამისი სინტაქსის გამოყენებით.',
        text7 : 'Profile და Gallery კომპონენტები გატანილია App.js-დან ახალ Gallery.js  ფაილში. ახლა თქვენ შეგიძლიათ შეცვალოთ App.js და დააიმპორტოთ Gallery კომპონენტი Gallery.js ფაილიდან.',
        text8 : 'ყურადღება მიაქციეთ, კომპონენტები როგორ არის დაყოფილი ორ ფაილში:',
        text9 : 'განსაზღვრულია Profile კომპონენტი, რომელიც გამოიყენება მხოლოდ ამ ფაილში და არ არის ექსპორტირებული.',
        text10 : 'ახდენს  Gallery კომპონენტის ექსპორტს, default export-ის გამოყენებით.',
        text11 : 'Gallery.js ფაილიდან დაიმპორტებულია Gallery კომპონენტი.',
        text12 : 'ახდენს ძირითადი  App კომპონენტის ექსპორტს, default export-ის გამოყენებით.',
        text13 : 'თქვენ შეიძლება შეგხვდეთ ფაილები, სადაც არ იქნება მითითებული .js  გაფართოება:',
        text14 : 'ორივე ჩანაწერი მუშაობს React-ში, თუმცა "./Gallery.js" უფრო ახლოს არის  კლასიკური ES მოდულების ჩაწერის სტილთან.',
        text15 : 'JavaScript-ში მნიშვნელობების ექსპორტის ორი ძირითადი გზა არსებობს: default და named ექსპორტი.  ჩვენს მაგალითებში გამოყენებულია მხოლოდ default ექსპორტი, მაგრამ თქვენ შეგიძლიათ გამოიყენოთ ერთი ან ორივე მათგანი ერთიდაიგივე ფაილში. ფაილში შეიძლება იყოს მხოლოდ ერთი default ექსპორტი, ხოლო named ექსპორტი იმდენი, რამდენიც გსურთ.',
        text16 : 'ის თუ რა გზით აექსპორტებთ კომპონენტს განსაზღვრავს იმ სინტაქსს , თუ როგორ შემოიტანთ მას სხვა ფაილში. შეუსაბამობის შემთხვევაში თქვენ მიიღებთ შეცდომას. ქვემოთ მოცემულ სქემა დაგეხმარებათ სინტაქსის სწორად შერჩევაში:',
        text17 : 'default იმპორტის შემთხვევაში, თქვენ შეგიძლიათ კომპონენტის სახელად გამოიყენოთ ნებისმიერი სახელი რაც მოგესურვებათ. მაგალითად, Button-ის ნაცვლად შეგიძლიათ დაწეროთ import Banana from "./Button.js" და თქვენ მაინც მიიღებთ იგივე კომპონენტს. ამის საპირისპიროდ, named იმპორტის დროს, სახელი ორივე ფაილში უნდა ემთხვეოდეს ერთმანეთს.',
        text18 : 'დეველოპერები ძირითადად იყენებენ default ექსპორტს მაშინ, თუ ფაილი მხოლოდ ერთ კომპონენტს შეიცავს, ხოლო  named ექსპორტს იყენებენ მაშინ, როცა ფაილში ბევრი კომპონენტი და მნიშვნელობაა. მიუხედავად იმისა, თუ რომელი კოდირების სტილს ანიჭებთ უპირატესობას, თქვენს შექმნილ კომპონენტებს, ფუნქციებს და მათ შემცველ ფაილებს ყოველთვის მიეცით აზრობრივად დატვირთული სახელები. უსახელო კომპონენტები შექმნა, მაგალითად  export default () => {}, არ არის  რეკომენდირებული.',
        text19 : 'როგორ უნდა მოვიქცეთ თუკი Gallery.js  ფაილიდან მხოლოდ Profile კომპონენტის შემოტანა გვსურს?  Gallery.js-ში  უკვე გამოყენებული გვაქვს default ექსპორტი და როგორც ზემოთ აღვნიშნეთ, ერთ ფაილში ორი default ექსპორტის გამოყენება  არ შეიძლება. ამ შემთხვევაში თქვენ შეგიძლიათ შექმნათ ახალი ფაილი და იქ გამოიყენოთ default ექსპორტი ან   დაამატოთ named ექსპორტი Profile კომპონენტს. ფაილში შეიძლება იყოს მხოლოდ ერთი default ექსპორტი, მაგრამ მას შეიძლება ჰქონდეს მრავალი named ექსპორტი!',
        text20 : 'default და named ექსპორტებთან დაკავშირებით გაუგებრობების თავიდან ასაცილებლად, პროექტზე მომუშავე გუნდის წევრები თანხმდებიან მათი გამოყენების ერთიან სტილზე. თქვენ შეგიძლიათ გამოიყენოთ ისინი თქვენი სურვილისამებრ.',
        text21 : 'პირველ რიგში , დააექსპორტეთ Profile კომპონენტი Gallery.js ფაილიდან named ექსპორტის გამოყენებით (default-ის  გარეშე):',
        text22 : 'შემდეგ, დააიმპორტეთ Profile კომპონენტი Gallery.js-დან App.js-ში named იმპორტის გამოყენებით (ფიგურულ ფრჩხილებში):',
        text23 : 'და ბოლოს,  თქვენ უკვე შეგიძლიათ გამოიყენოთ <Profile /> კომპონენტი App კომპონენტში:',
        text24 : 'Gallery.js უკვე შეიცავს ორ ექსპორტს: Gallery კომპონენტის default ექსპორტს და  Profile კომპონენტის named ექსპორტს, რომლებიც App.js-ში იმპორტირდება შესაბამისი სინტაქსით:',
        text25 : 'მოცემულ მაგალითში  ვიყენებთ default და named ექსპორტების ნაზავს:',
        text26 : 'ახდენს Profile კომპონენტის ექსპორტს named ექსპორტის გამოყენებით',
        text27 : 'ახდენს Gallery  კომპონენტის ექსპორტს , default ექსპორტის გამოყენებით',
        text28 : 'აიმპორტებს Profile კომპონენტს Gallery.js-დან, named იმპორტის გამოყენებით',
        text29 : 'აიმპორტებს Gallery კომპონენტს Gallery.js-დან, default იმპორტის გამოყენებით',
        text30 : 'ახდენს მთავარ App კომპონენტის default ექსპორტს',
        text31 : 'რა არის მთავარი კომპონენტი',
        text32 : 'როგორ ხდება კომპონენტების იმპორტი და ექსპორტი',
        text33 : 'როდის და როგორ გამოვიყენოთ default და named იმპორტი და ექსპორტი',
        text34 : 'როგორ მოვახდინოთ რამდენიმე კომპონენტის ექსპორტი ერთი და იგივე ფაილიდან'
    },
    article6 : {
        text1 : 'JSX არის JavaScript-ის სინტაქსის გაფართოება, რომელიც საშუალებას გაძლევთ ჩაწეროთ HTML-ის მსგავსი მარკირება JavaScript-ის ფაილში. მიუხედავად იმისა, რომ არსებობს კომპონენტების შექმნის სხვა გზებიც, React-ის დეველოპერების უმეტესობა უპირატესობას ანიჭებს JSX-ის ლაკონურობას და იყენებს მას.',
        text2 : 'ვები დაფუძვნებულია HTML, CSS და JavaScript-ზე. მრავალი წლის განმავლობაში, ვებ დეველოპერები კონტენტს ქმნიდნენ HTML-ში, დიზაინს CSS-ში და ხოლო ლოგიკას  JavaScript-ში - ხშირად ცალკ-ცალკე ფაილებში. კონტენტი მოთავსებული იყო HTML-ში, ხოლო ფუნქციონალი კონტენტისგან იზოლირებულად  JavaScript-ში:',
        text3 : 'მაგრამ დროთა განმავლობაში ვები სულ უფრო ინტერაქტიული ხდებოდა და ლოგიკა სულ უფრო მეტად განსაზღვრავდა კონტენტს. JavaScript გახდა პასუხისმგებელი HTML-ის სტრუქტურაზე. სწორედ ამიტომ React-ში ლოგიკა და მარკირება ერთად თანაცხოვრობენ ერთსა და იმავე ადგილას - კომპონენტებში.',
        text4 : 'ღილაკის ფუნქციონალური ლოგიკისა და მარკირების ერთად შენახვა უზრუნველყოფს მის სინქრონიულ ცვლილებას ყველგან  ყოველი რედაქტირებისას, ხოლო დეტალები, რომლებიც ერთმანეთთან არ არის დაკავშირებული, როგორიცაა მაგალითად, ღილაკის და ნავიგაციის პანელის მარკირება, იზოლირებულია ერთმანეთისგან, რაც უფრო უსაფრთხოს ხდის რომელიმე მათგანის დამოუკიდებლად რედაქტირებას.',
        text5 : 'თითოეული React კომპონენტი არის JavaScript-ის ფუნქცია, რომელიც შეიძლება შეიცავდეს  მარკირებას, რომელსაც React-ი შემდგომ აწვდის ბრაუზერს. React კომპონენტები იყენებენ სინტაქსურ გაფართოებას სახელწოდებით JSX. JSX ძალიან ჰგავს HTML-ს, მაგრამ უფრო მკაცრია და შეუძლია დინამიური ინფორმაციის გამოტანა.',
        text6 : 'JSX და React ორი განსხვავებული რამ არის. ისინი ხშირად გამოიყენება ერთად, მაგრამ შესაძლებელია მათი დამოუკიდებლად გამოყენებაც. JSX არის სინტაქსის გაფართოება, ხოლო React არის JavaScript ბიბლიოთეკა.',
        text7 : 'ეს იმიტომ ხდება, რომ JSX უფრო მკაცრია და აქვს HTML-ისგან განსხვავეული რამოდენიმე წესი. შეცდომის შეტყობინებები დაგეხმარებათ შეასწოროთ მარკირება.',
        text8 : 'უმეტეს შემთხვევაში, ეკრანზე გამოტანილი შეცდომის შეტყობინებები დაგეხმარებათ იპოვოთ პრობლემა. წაიკითხეთ ისინი ყურადღებით!',
        text9 : 'ბევრი ელემენტისგან შემდგარი კომპონენტებიდან ელემენტის დასაბრუნებლად, მოათავსეთ ისინი ერთი მშობელ ტეგში.',
        text10 : 'მაგალითად, შეგიძლიათ გამოიყენოთ <div> ტეგი:',
        text11 : '<div>-ის ნაცვლად შეგიძლიათ ასევე გამოიყენოთ ცარიელი ტეგის ფრაგმენტი <> და </> :',
        text12 : 'ფრაგმენტები საშუალებას გაძლევთ დააჯგუფოთ ელემენტები ბრაუზერის HTML ხეში ზედმეტი ელემენტების დამატების გარეშე.',
        text13 : 'რატომ არის საჭირო  JSX ტეგების მშობელ ელემენტში მოთავსება?',
        text14 : 'JSX ჰგავს HTML-ს, მაგრამ კომპილაციის შემდეგ ის გარდაიქმნება უბრალო JavaScript ობიექტებად. თქვენ არ შეგიძლიათ დააბრუნოთ ორი ობიექტი ფუნქციიდან, მათი მასივში მოთავსების გარეშე. ამით აიხსნება, თუ რატომ არ შეიძლება დააბრუნდეს ორი ან მეტი JSX ტეგი ერთ მშობელ ტეგში ან  ფრაგმენტში მოთავსების გარეშე.',
        text15 : 'JSX მოითხოვს ყველა ტეგების დახურვას: თვითდახურვადი ტეგები, როგორიცაა, მაგალითად <img>, JSX-ში უნდა ჩაიწეროს , როგორც <img />, ხოლო  <li>oranges უნდა ჩაიწეროს როგორც <li>oranges</li>.',
        text16 : 'ასე გამოიყურება  სურათი და სიის ელემენტების სწორად დახურული ტეგები:',
        text17 : 'JSX იქცევა JavaScript ობიექტად და JSX-ში დაწერილი ატრიბუტები ხდება JavaScript ობიექტების key მნიშვნელობები.  JavaScript-ს აქვს შეზღუდვები ცვლადის სახელებზე. მაგალითად, მათი სახელები არ შეიძლება შეიცავდეს ტირეებს, ასევე არ შეიძლება დარეზერვებული სიტყვების გამოყენება, მაგალითად, როგორიცაა class.',
        text18 : 'სწორედ ამიტომ, React-ში ბევრი HTML და SVG ატრიბუტი იწერება camelCase-ში. მაგალითად, stroke-width ატრიბუტის ნაცვლად უნდა გამოიყეენოთ strokeWidth. ვინაიდან class დარეზერვებული სიტყვაა, React-ში მის ნაცვლად გამოიყენება className:',
        text19 : 'თუ  შეგეშალათ, არ ინერვიულოთ - React გამოიტანს შეცდომის შეტყობინებას ბრაუზერის კონსოლში შესაძლო შესწორებით.',
        text20 : 'მხოლოდ aria - * და data - * ატრიბუტები იწერება ტირეებით, ისევე როგორც HTML-ში.',
        text21 : 'უკვე არსებულ HTML მარკირებიდან ყველა ატრიბუტის JSX სტილზე  გარდაქმნა შეიძლება დამღლელი იყოს. გირჩევთ გამოიყენოთ ',
        text22 : 'HTML-იდან და SVG-დან JSX-ზე კონვერტირებისთვის. კონვერტორები პრაქტიკაში ძალიან სასარგებლოა, მაგრამ აუცილებელია იმის ცოდნა, თუ როგორ მუშაობს JSX, რათა კომფორტულად წეროთ კოდი დამოუკიდებლად.',
        text23 : 'ახლა თქვენ უკვე იცით, რა არის JSX და როგორ გამოიყენოთ იგი კომპონენტებში:',
        text24 : 'React კომპონენტები აჯგუფებს  ლოგიკას და  მარკირებას ერთად, რადგან ისინი დაკავშირებულია.',
        text25 : 'JSX HTML-ის მსგავსია, რამდენიმე განსხვავებებით. საჭიროების შემთხვევაში შეგიძლიათ გამოიყენოთ კონვერტორი.',
        text26 : 'შეცდომის შეტყობინებები ხშირად მიგითითებთ სწორ ვარიანტს თქვენი მარკირების გამოსასწორებლად.',
    },
    article7 : {
        text1 : 'JSX საშუალებას გვაძლევს ჩავწეროთ HTML-ის მსგავსი მარკირება JavaScript-ის ფაილში და თან მოვათავსოთ  ლოგიკა და კონტენტი ერთსა და იმავე ადგილას. ზოგჯერ JSX მარკირების შიგნით საჭირო ხდება უფრო მეტი JavaScript ლოგიკის ან დინამიური მნიშვნელობების დამატება. ამ შემთხვევაში, შეგიძლიათ გამოიყენოთ ფიგურული ფრჩხილები  JSX-ში JavaScript-ის „ფანჯრის“ გასახსნელად.',
        text2 : 'JSX ატრიბუტზე სტინგული მნიშვნელობის გადასაცემად გამოიყენება ერთმაგი ან ორმაგი ბრჭყალები:',
        text3 : 'ამ მაგალითში  "https://i.imgur.com/7vQD0fPs.jpg" და "Gregorio Y. Zara" შესაბამის ატრიბუტებს სტრინგის სახით გადაიცემა.',
        text4 : 'იმ შემთხვევაში თუ დინამიური მნიშვნელობების გადაცემა გინდათ , მაგალითად  src ან alt ატრიბუტებისთვის, თქვენ შეგიძლიათ ბრჭყალები  " "  ჩაანაცვლოთ ფიგურული ფრჩხილებით { } :',
        text5 : 'მიაქციეთ ყურადღება  className="avatar" და src={avatar} ჩანაწერებს შორის განსხვავებას.  პირველ შემთხვევაში className="avatar"  განსაზღვრავს "avatar"  CSS კლასის სახელს სურათის კიდეების მოსამრგვალებლად, ხოლო მეორე შემთხვევაში, src ატრიბუტი მონაცემებს იღებს avatar ცვლადიდან. ფიგურული ფრჩხილები საშუალებას გაძლევთ იმუშაოთ JavaScript-ით  თქვენს მარკირებაში.',
        text6 : 'JSX არის JavaScript-ის ჩაწერის სპეციალური გზა. ეს ნიშნავს, რომ მასში JavaScript-ის გამოყენება შესაძლებელია — ფიგურული ფრჩხილების  { } მეშვეობით. ქვემოთ მოყვანილ მაგალითში ჯერ გამოაცხადებულია  name ცვლადი მეცნიერის სახელით, შემდეგ კი ფიგურული ფრჩხილების გამოყენებით  მოთავსებულია <h1> ტეგში:',
        text7 : 'თუკი შევცვლით name ცვლადის მნიშვნელობას "Gregorio Y. Zara"-დან "Hedy Lamarr"-ზე, ვნახავთ რომ, სათაურიც შეიცვლება.',
        text8 : 'ფიგურულ ფრჩხილებს შიგნით მუშაობს JavaScript-ის ნებისმიერი გამოსახულება, მათ შორის ფუნქციის გამოძახებაც, მაგალითად როგორიცაა ფუნქცია formatDate():',
        text9 : 'თქვენ შეგიძლიათ JSX-ში გამოიყენოთ ფიგურული ფრჩხილები  მხოლოდ ორი გზით:',
        text10 : "1.	როგორც ტექსტი პირდაპირ JSX ტეგის შიგნით: <h1>{name}'s To Do List</h1> იმუშავებს, მაგრამ <{tag}>Gregorio Y. Zara's To Do List</{tag}> არა.",
        text11 : '2. როგორც ატრიბუტები  =  ტოლობის ნიშნის შემდეგ: src={avatar} წაიკითხავს avatar ცვლადის მნიშვნელობას, მაგრამ src="{avatar}" სტრინგის სახით მოგვცემს  "{avatar}".',
        text12 : 'სტრინგების, რიცხვების და სხვა JavaScript მნიშვნელობების გარდა, JSX-ში ობიექტების გადაცემაც კი შეგიძლიათ. ობიექტები ასევე მოთავსებულია ფიგურულ ფრჩხილებში, მაგალითად { name: "Hedy Lamarr", inventions: 5 }. ამიტომ, JS ობიექტის JSX-ში გამოსაყენებლად, თქვენ უნდა მოათავსოთ ობიექტი კიდევ ერთ ფიგურულ ფრჩხილებში: person={{ name: "Hedy Lamarr", inventions: 5 }}.',
        text13 : 'ამის მაგალითია  inline CSS სტილები JSX-ში. React არ საჭიროებს  inline სტილების გამოყენებას (CSS კლასები მშვენივრად მუშაობს უმეტეს შემთხვევაში). მაგრამ როდესაც გვჭირდება inline სტილი,  style ატრიბუტს უნდა გადავცეთ ისინი ობიექტის სახით:',
        text14 : 'სცადეთ და შეცვალეთ backgroundColor-ის და color-ის  მნიშვნელობები.',
        text15 : 'ქვემოთ მოცემულ ჩანაწერში უფრო ნათლად ჩანს JSX-ის და ობიექტის ფიგურული ფრჩხილები:',
        text16 : 'შემდეგ ჯერზე, როცა შეგხვდებათ ორმაგი ფიგურული ფრჩხილები     {{  }}  JSX-ში, იცოდეთ, რომ ეს სხვა არაფერია, თუ არა ობიექტი JSX ფიგურულ ფრჩხილებს შიგნით!',
        text17 : "Inline სტილებში თვისებები იწერება camelCase-ში. მაგალითად, HTML <ul style='background-color: black'>, JSX-ში დაიწერება როგორც <ul style={{ backgroundColor: 'black' }}> .",
        text18 : 'თქვენ შეგიძლიათ მოათავსოთ რამდენიმე მნიშვნელობა ერთ ობიექტში და გამოიყენოთ ისინი JSX-ში ფიგურული ფრჩხილების  შიგნით:',
        text19 : 'ამ მაგალითში, person ობიექტი შეიცავს name სტრინგს და theme ობიექტს:',
        text20 : 'JSX როგორც შაბლონის ენა,  ძალიან მინიმალისტურია. ის საშუალებას გვაძლევს ერთ სივრცეში მოაწყოთ მონაცემები და ლოგიკა JavaScript-ის გამოყენებით.',
        text21 : 'ახლა თქვენ იცით თითქმის ყველაფერი JSX-ის შესახებ:',
        text22 : 'JSX-ში ატრიბუტებს მნიშვნელობები გადაეცემა ბრჭყალებში, როგორც სტინგები.',
        text23 : 'ფიგურული ფრჩხილები საშუალებას გაძლევთ შემოიტანოთ JavaScript ლოგიკა და ცვლადები თქვენს მარკირებაში.',
        text24 : 'ისინი მუშაობენ JSX ტეგის კონტენტში ან ატრიბუტებში = ტოლობის ნიშნის შემდეგ.',
        text25 : 'ორმაგი ფრჩხილები {{  }} არ არის სპეციალური სინტაქსი: ეს არის JavaScript ობიექტი, რომელიც მოთავსებულია JSX -ის ფიგურულ ფრჩხილებში'        
    },
    article8 : {
        text1 : 'React კომპონენტები იყენებენ props-ებს ერთმანეთთან კომუნიკაციისთვის. თითოეულ მშობელ კომპონენტს შეუძლია გადასცეს გარკვეული ინფორმაცია თავის შვილობილ კომპონენტებს props-ების საშუალებით. Props-ებმა შეიძლება გაგახსენოთ HTML ატრიბუტები, თუმცა თქვენ შეგიძლიათ გადასცეთ JavaScript-ის ნებისმიერი მნიშვნელობა, მათ შორის ობიექტები, მასივები და ფუნქციები.',
        text2 : 'პროპსები არის ინფორმაცია, რომელსაც გადასცემთ JSX ტეგს. მაგალითად, className, src, alt, width, და height არის ჩვენთვის უკვე ნაცნობი პროპსები, რომლითაც შეგიძლიათ გადასცეთ ინფორმაცია <img> ტეგს:',
        text3 : 'პროპსები, რომლებიც შეგიძლიათ გადასცეთ <img> ტეგს, წინასწარ არის განსაზღვრული (ReactDOM შეესაბამება HTML სტანდარტს ),  მაგრამ თქვენ შეგიძლიათ გადასცეთ ნებისმიერი პროპსი თქვენს საკუთარ კომპონენტებს, მაგალითად როგორიცაა <Avatar>.',
        text4 : 'ამ მაგალითში Profile კომპონენტი არ გადასცემს რაიმე პროპს თავის შვილობილ კომპონენტ Avatar-ს:',
        text5 : 'პირველ რიგში, გადაეცით რამდენიმე პროპსი Avatar კომპონენტს. მაგალითად, person (ობიექტი) და size (რიცხვი):',
        text6 : 'თუ person= შემდეგ ორმაგმა ფიგურულმა ფრჩხილებმა  დაგაბნიეს, გაიხსენეთ, რომ ისინი უბრალოდ ობიექტია JSX -ს ფიგურული ფრჩხილების შიგნით.',
        text7 : 'თქვენ უკვე შეგიძლიათ გამოიყენოთ ეს პროპსები Avatar კომპონენტის შიგნით.',
        text8 : 'თქვენ შეგიძლიათ გამოიყენოთ პროპსები მათი სახელების ჩამოთვლით, (person, size) რომლებიც ერთმანეთისგან გამოყოფილია მძიმეებით და მოთავსებულია  ({ და }) ფრჩხილებს შიგნით function Avatar ჩანაწერის შემდეგ. ეს საშუალებას გაძლევთ გამოიყენოთ ისინი Avatar კოდის შიგნით, როგორც ამას გააკეთებთ ცვლადის შემთხვევაში.',
        text9 : 'დავამატოთ გარკვეული ლოგიკა Avatar კომპონენტს, რომელიც გამოიყენებს person და size პროპსებს რენდერისთვის.',
        text10 : 'პროპსები საშუალებას გაძლევთ დამოუკიდებლად მართოთ მშობლი და შვილობილი კომპონენტი. მაგალითად, თქვენ შეგიძლიათ შეცვალოთ  person ან size პროპსები  Profile კომპონენტში, ისე, რომ არ იფიქროთ იმაზე, თუ როგორ იყენებს  Avatar კომპონენტი მათ. ანალოგიურად, თქვენ შეგიძლიათ შეცვალოთ Avatar კომპონენტში ამ პროპსების გამოყენების ლოგიკა , Profile კომპონენტისგან დამოუკიდებლად.',
        text11 : 'პროპსები ასრულებენ იგივე როლს, რასაც არგუმენტები ფუნქციებში - სინამდვილეში, პროპსები თქვენი კომპონენტის ერთადერთი არგუმენტია ! React კომპონენტის ფუნქციები იღებენ ერთ არგუმენტს -  props ობიექტს:',
        text12 : 'როგორც წესი, თქვენ არ გჭირდებათ მთლიანი props ობიექტი, ამის გამო ხდება მისი დესტრუქტურიზაცია ინდივიდუალურ პროპსებად.',
        text13 : 'არ გამოტოვოთ წყვილი ფიგურული ფრჩხილები { }  ჩვეულებრივი ფრჩხილების ( )  შიგნით პროპსების გამოცხადებისას:',
        text14 : 'ამ სინტაქსს ეწოდება "დესტრუქტურიზაცია" და ფუნქციის პარამეტრებიდან თვისებების წაკითხვის ექვივალენტურია:',
        text15 : 'თუ გსურთ, რომ პროპს  მიანიჭოთ default მნიშვნელობა, რომელიც გამოყენებული იქნება იმ შემთხვევაში, თუ პროპსის მნიშვნელობა არ იქნება გადაცემული კომპონენტზე, ამის გაკეთება გაკეთება შეგიძლიათ დესტრუქტურიზაციის გამოყენებით, ტოლობის ნიშნის შემდგომ  default მნიშვნელობის მითითებით:',
        text16 : 'თუკი <Avatar person={...} /> კომპონენტი დარენდერდება  size პროპსის მითითების  გარეშე, size ავტომატურად იქნება  100-ის ტოლი.',
        text17 : 'default  მნიშვნელობა გამოიყენება მხოლოდ იმ შემთხვევაში, თუ size პროპსი არ მიეთითება  ან როცა size={undefined}. მაგრამ იმ შემთხევვაში თუ  size={null} ან size={0}, default მნიშვნელობა არ იქნება გამოყენებული.',
        text18 : 'განმეორებით კოდში ცუდი არაფერია - ის შეიძლება უფრო კითხვადიც კი იყოს. მაგრამ ზოგჯერ შეიძლება ლაკონურობა უფრო დაგვჭირდეს. ზოგიერთი კომპონენტი თავის შვილობილ კომპონენტს გადასცემს ყველა პროპს, მაგალითად, როგორ Profile კომპონენტში. იმის გამო, რომ არცერთი კომპონენტი პროპს პირდაპირ არ იყენებენ, შეიძლება უფრო გონივრული იყოს  ლაკონური „spread“ სინტაქსის გამოყენება:',
        text19 : 'ამ გზით შეგვიძლია გადავცეთ   Profile კომპონენტის ყველა პროპსი  Avatar კომპონენტს თითოეულ მათგანს სახელების ჩამოთვლის გარეშე.',
        text20 : 'გამოიყენეთ ეს სინტაქსი ყურადღებით! თუ თქვენ იყენებთ მას თითქმის ყველა კომპონენტში, ესე იგი რაღაც არასწორია. ხშირად, ეს მიუთითებს იმაზე, რომ კომპონენტები საჭიროებს დაყოფას და შვილობილ ელემენტები საჭიროა გადასცეთ JSX-ის სახით.',
        text21 : 'ჩვეულებრივი  HTML-ში შესაძლებელია ტეგების ერთმანეთში ჩალაგება:',
        text22 : 'ხანდახან საჭიროა საკუთარი კომპონენტების იმავე პრინციპით ერთმანეთში ჩალაგება:',
        text23 : 'როდესაც თქვენ კონტენტს მოათავსებთ JSX ტეგში, მშობელი ამ კომპონენტს მიიღებს პროპსის სახით, სახელწოდებით children. მაგალითად, ქვემოთ მოყვანილი Card კომპონენტი children პროპსად მიიღებს <Avatar/> კომპონენტს და მოათავსებს მას div-ში:',
        text24 : 'სცადეთ შეცვალოთ <Card>-ში  <Avatar> კომპონენტი  რაიმე ტექსტით, რათა ნახოთ, როგორ შეუძლია  Card კომპონენტს მიიღოს ნებისმიერი შინაარსის  კონტენტი. მას არ სჭირდება "იცოდეს" რა ხდება ამ კონტენტის შიგნით. ამ მოქნილ ნიმუშს ბევრგან ნახავთ.',
        text25 : 'თქვენ შეგიძლიათ წარმოიდგინოთ, რომ კომპონენტს აქვს პროპსი children როგორც „ხვრელი“, რომლის „შევსება“ შესაძლებელია საკუთარი კომპონენტების JSX-ით.',
        text26 : 'ქვემოთ მაგალითში მოცემული Clock კომპონენტი მშობელი კომპონენტისგან იღებს ორ პროპს: color და time. (მშობელი კომპონენტის კოდი გამოტოვებულია, რადგან ის იყენებს state-ს , რომელსაც ჯერ არ შევხებივართ).',
        text27 : 'ეს მაგალითი გვიჩვენებს, რომ კომპონენტმა შეიძლება დროთა განმავლობაში მიიღოს სხვადასხვა პროპსი. ისინი ყოველთვის არ არიან სტატიკურები! მოცემულ მაგალითში  time პროპსი  ყოველ წამს იცვლება და ხოლო color პროპსი  იცვლება სხვა ფერის არჩევისას. პროპსები ასახავს კომპონენტის მონაცემებს დროის ნებისმიერ მომენტში, და არა მხოლოდ დასაწყისში.',
        text28 : 'თუმცა, პროპსები არიან immutable - ტერმინი კომპიუტერული მეცნიერებიდანაა, რაც ნიშნავს "უცვლელს". როდესაც კომპონენტმა უნდა შეცვალოს პროპსი (მაგალითად, მომხმარებლის ქმედებებზე საპასუხოდ  ან ახალი მონაცემების მიღების შემთხვევაში), მას მოუწევს „სთხოვოს“ მის მშობელ კომპონენტს გადასცეს სხვა პროპსები  - ახალი ობიექტი!  ძველი პროპსები ჩანაცვლდება ახლით და საბოლოოდ JavaScript-ის ძრავა გამოიყენებს მათ მიერ დაკავებულ მეხსიერებას.',
        text29 : 'ნუ ეცდებით „შეცვალოთ პროპსები“. როდესაც თქვენ გჭირდებათ პასუხის გაცემა მომხმარებლის ქმედებაზე (როგორიცაა სიიდან შერჩეული ფერის შეცვლა), თქვენ უნდა გამოიყენოთ „state“, რომლის შესახებაც საუბარი გვექნება შემდეგ თავებში.',
        text30 : 'პროპსების გადასაცემად, დაამატეთ ისინი JSX-ში, ისევე, როგორც ამას გააკეთებდით HTML ატრიბუტების შემთხვევაში.',
        text31 : 'პროპსების მისაღებად გამოიყენეთ დესტრუცტურიზაციის სინტაქსი function Avatar({ person, size })',
        text32 : 'თქვენ შეგიძლიათ მიუთითოთ default მნიშვნელობა, მაგალითად როგორიცაა size = 100, რომელიც გამოიყენება გამოტოვებული და undefined პროპსებისთვის.',
        text33 : 'თქვენ შეგიძლიათ გადააგზავნოთ ყველა პროპსი JSX spread სინტაქსით  <Avatar {...props} />, მაგრამ  ზედმეტად ნუ გამოიყენებთ მას!',
        text34 : 'ერთმანეთში ჩადგმული კომპონენტები  <Card><Avatar /></Card>, წარმოდგენილი იქნება  როგორც Card კომპონენტის children პროპსი.',
        text35 : 'პროპსები  წაკითხვადია  დროის გარკვეულ მონაკვეთში: ყველა შემდეგი რენდერი იღებს პროპსების ახალ ვერსიას.',
        text36 : 'არ შეიძლება პროპსების შეცვლა მაშინ,  როდესაც გჭირდებათ ინტერაქტიულობა. ასეთ შემთხვევაში თქვენ უნდა გამოიყენოთ state.'
    },
    article9 : {
        text1 : 'თქვენს აპლიკაციაში ხშირად დაგჭირდებათ კომპონენტების გამოტანა სხვადასხვა პირობებიდან გამომდინარე. React-ში შეგიძლიათ  პირობების გათვალისწინებით JSX გამოიტანოთ JavaScript სინტაქსის გამოყენებით, როგორიცაა if, &&  და ? : ოპერატორები.',
        text2 : 'დავუშვათ, რომ თქვენ გაქვთ PackingList კომპონენტი, რომელიც ასახავს რამდენიმე Item კომპონენტს, რომელზეც შეიძლება იყოს განსზღვრული isPacked პირობა:',
        text3 : 'გაითვალისწინეთ, რომ ზოგიერთ Item კომპონენტს  isPacked  პროპსი  true-ს ნაცვლად მითითებულია false. თუ isPacked={true},  შეფუთულ ნივთებს უნდა დაემატოს  ნიშანი (✔).',
        text4 : 'ამის გასაკეთებლად შეგვიძლია გამოვიყენოთ if / else სინტაქსი:',
        text5 : 'თუ isPacked პროპსი  არის true, ეს კოდი დააბრუნებს სხვა JSX. ამ ცვლილებით, ზოგიერთი ელემენტი ბოლოში იღებს ✔ ნიშანს:',
        text6 : 'დააკვირდით, როგორ იქმნება განშტოების სხვადასხვა ლოგიკა JavaScript-ის if და return ოპერატორების მეშვეობით. React-ში კოდის კონტროლის ნაკადი (მაგალითად პირობები) იმართება JavaScript-ით.',
        text7 : 'ზოგიერთ სიტუაციაში, თქვენ საერთოდ გჭირდებათ რაიმეს გამოჩენა. მაგალითად, არ გსურთ შეფუთული ნივთების ჩვენება. ამ შემთხვევაში, შეგიძლიათ უბრალოდ დააბრუნოთ null:',
        text8 : 'ამ მაგალითში თუ isPacked = { true }, კომპონენტი დააბრუნებს null-ს ანუ არაფერს. წინააღმდეგ შემთხვევაში, ის დააბრუნებს JSX-ს რენდერისთვის.',
        text9 : 'პრაქტიკაში, კომპონენტიდან null-ის დაბრუნება არ არის გავრცელებული. უფრო ხშირად ხდება მშობელი კომპონენტის JSX-ში შვილობილი კომპონენტების პირობითად გამოჩენა ან გაქრობა.',
        text10 : 'წინა მაგალითში თქვენ აკონტროლებდით, რომელი (ასეთის არსებობის შემთხვევაში!) JSX განშტოება დაბრუნდებოდა კომპონენტის მიერ. თქვენ შეიძლება უკვე შენიშნეთ დუბლირება რენდერის საბოლოო ვერსიაში:',
        text11 : 'ორივე პირობითი განშტოება აბრუნებს <li className="item">...</li> :',
        text12 : 'მიუხედავად იმისა, რომ ეს დუბლირება არ არის საგანგაშო, ამან შეიძლება გაართულოს თქვენი კოდის შემდგომი ოპტიმიზაცია. რა მოხდება, თუ თქვენ დაგჭირდებათ შეცვალოთ className? მოგიწევთ რომ შეცვალოთ კოდში ორ ადგილას! ასეთ სიტუაციაში, უმჯობესია პირობითად იცვლებოდეს  JSX-ის ის მცირე ნაწილი, რომელიც აუცილებელია, რათა თქვენი კოდი უფრო ოპტიმალური იყოს.',
        text13 : 'JavaScript-ში არსებობს პირობითი გამოსახულებების ჩასაწერი კომპაქტური სინტაქსი  - პირობითი (ternary) ოპერატორი:',
        text14 : 'ეს შეგიძლიათ წაიკითხოთ ასე „თუ isPacked = true, (?) მაშინ გამოიტანე name + "✔",  (:)  წინააღმდეგ შემთხვევაში გამოიტანე name“.',
        text15 : 'ეს ორი მაგალითი სრულიად ექვივალენტურია?',
        text16 : 'თუ თქვენ გაქვთ ობიექტზე ორიენტირებული პროგრამირების გამოცდილება, შეიძლება ივარაუდოთ, რომ ზემოთ მოცემული ორი მაგალითი ცოტათი განსხვავებულია, რადგან ერთმა მათგანმა შეიძლება შექმნას ორი განსხვავებული  <li> ეგზემპლიარი. მაგრამ JSX ელემენტები არ არის „ეგზემპლიარები“, რადგან ისინი არ ფლობენ რაიმე შიდა მდგომარეობას და არ არიან ნამდვილი DOM კვანძები. ისინი მხოლოდ კვანძების მსუბუქი აღწერილობებია, როგორც  მონახაზები. ასე რომ, ეს ორი მაგალითი, იდეურად, სრულიად ექვივალენტურია.',
        text17 : 'ახლა დავუშვათ, რომ გსურთ შესრულებული ელემენტის ტექსტის შეტანა სხვა HTML ტეგში, როგორიცაა მაგალითად <del>. თქვენ შეგიძლიათ გამოიყენოთ მრგვალი ფრჩხილები რათა დაამატოთ კიდევ უფრო მეტი JSX თქვენს კოდში:',
        text18 : 'ეს სტილი კარგად მუშაობს მარტივი პირობებისთვის, მაგრამ გამოიყენეთ იგი ზომიერად. თუ თქვენი კომპონენტები ჩახლართულია ზედმეტად ბევრი ჩადგმული პირობითი რენდერის გამო, ამის მოგვარების ერთერთ ვარიანტად განიხილეთ შვილობილი კომპონენტების განცალკევება მშობელი კომპონენტებისგან. React-ში მარკირება თქვენი კოდის ნაწილია, ასე რომ თქვენ შეგიძლიათ გამოიყენოთ ინსტრუმენტები, როგორიცაა ცვლადები და ფუნქციები, რთული ლოგიკის პირობების მოსაწესრიგებლად.',
        text19 : 'კიდევ ერთი გავრცელებული სინტაქსი, რომელსაც შეხვდებით, არის JavaScript-ის ლოგიკური AND (&&) ოპერატორი. React-ის კომპონენტებში  ხშირად ხდება, როდესაც გსურთ JSX-ის რენდერი, როდესაც პირობა არის ჭეშმარიტია, ხოლო წინააღმდეგ შემთხევაში არ გამოიტანოს არაფერი. && ოპერატორის მეშვეობით თქვენ შეგიძლიათ ჩასვათ ✔ ნიშანი მხოლოდ იმ შემთხვევაში, თუ isPacked არის true:',
        text20 : 'ამ ჩანაწერის წაკითხვა შემდეგნაირად შეიძლება: "თუ isPacked არის true, (&&) მაშინ  ჩასვი ✔ ნიშანი, წინააღმდეგ შემთხვევაში, არაფერი გამოიტანო".',
        text21 : '&& ოპერატორი JavaScript-ში აბრუნებს მისი მარჯვენა მხარის მნიშვნელობას (ჩვენს შემთხვევაში,  ✔ ნიშანი), თუ მარცხენა მხარე (ჩვენი პირობა) არის true. მაგრამ თუ პირობა არის false, მთელი გამოსახულება ხდება ასევე false. React-ი  false მნიშვნელობას განიხილავს როგორც "ხვრელს" JSX განშტოებაში, ისევე, როგორც null ან undefined, და მის ადგილას არაფერი არ გამოაქვს.',
        text22 : '&& ოპერატორის მარცხენა მხარეს არ გამოიყენოთ რიცხვები',
        text23 : 'პირობის შესამოწმებლად JavaScript ავტომატურად გარდაქმნის მარცხენა მხარეს ლოგიკურ მნიშვნელობად. თუმცა, თუ მარცხენა მხარე არის 0-ის ტოლი, მაშინ მთელი გამოსახულება მიიღებს ამ მნიშვნელობას (0) და React-ი არაფერს ნაცვლად, მნიშვნელობის სახით გამოიტანს  0-ს.',
        text24 : 'მაგალითად, გავრცელებული შეცდომაა ისეთი კოდის დაწერა, როგორიცაა messageCount && <p>New messages</p>. ადვილია ვივარაუდოთ, რომ ეს ჩანაწერი არაფერს გამოიტანს, როდესაც messageCount იქნება 0, მაგრამ სინამდვილეში ის გამოიტანს 0-ს!',
        text25 : 'ამის  გამოსასწორებლად გადაკეთეთ მარცხენა მხარე ლოგიკურ მნიშვნელობად: messageCount > 0 && <p>New messages</p>.',
        text26 : 'JSX -ის პირობითად მნიშვნელობის სახით ცვლადზე მინიჭება',
        text27 : 'როდესაც ზემოთ აღწერილი მეთოდები ხელს უშლის მარტივი კოდის დაწერას, სცადეთ გამოიყენოთ if ოპერატორი და ცვლადები. let-ით განსაზღვრულ ცვლადებს შეგიძლიათ  ხელახლა მინიჭოთ მნიშვნელობები:',
        text28 : 'გამოიყენეთ if ოპერატორი რათა მიანიჭოთ itemContent ცვლადს ახალი მნიშვნელობა თუკი isPacked არის true:',
        text29 : 'როგორც გახსოვთ, ფიგურული ფრჩხილები ხსნის "JavaScript-ის ფანჯარას". მოათავსეთ ცვლადი ფიგურულ ფრჩხილებში და ჩასვით JSX-ში:',
        text30 : 'ეს სტილი უფრო დიდია ზომაში, თუმცა ყველაზე მოქნილია:',
        text31 : 'როგორც წინა მაგალითებში, ისე აქაც ეს მეთოდი მუშაობს არა მხოლოდ ტექსტისთვის, არამედ  JSX-ისთვისაც:',
        text32 : 'თუ თქვენ აქამდე არ გქონით შეხება JavaScript-თან, პირობითი რენდერის ჩაწერის სტილების ამ მრავალფეროვნებამ თავიდან შეიძლება დაგაბნიოთ. თუმცა, მათი სწავლა დაგეხმარებათ წაიკითხოთ და დაწეროთ JavaScript-ის ნებისმიერი კოდი - და არა მხოლოდ React კომპონენტები! დასაწყისისთვის აირჩიეთ თქვენთვის სასურველი სინტაქსი და თუ დაგავიწყდათ, როგორ მუშაობენ სხვები, შემდეგში ისევ მიმართეთ ამ სახელმძღვანელოს.',
        text33 : 'React-ში თქვენ აკონტროლებთ კვანძების განშტოების ლოგიკას JavaScript-ით.',
        text34 : 'შეგიძლიათ პირობითად დააბრუნოთ JSX გამოსახულება if ოპერატორის საშუალებით.',
        text35 : 'შეგიძლიათ პირობითად შეინახოთ ზოგიერთი JSX ცვლადში და შემდეგ ჩასვათ იგი სხვა JSX-ში ფიგურული ფჩხილების გამოყენებით.',
        text36 : 'JSX-ში {cond ? <A/> : <B/>} ნიშნავს, რომ "თუ cond ჭეშმარიტია, დაარენდერე <A/>, თუ არა დაარენდერე <B/>".',
        text37 : 'JSX-ში {cond && <A/>} ნიშნავს "თუ cond ჭეშმარიტია, დაარენდერე <A/>, წინააღმდეგ შემთხვევაში არაფერი დაარენდერო".',
        text38 : 'თუ თქვენთვის უფრო მარტივია if ოპერატორი, არ არის აუცილებელი სხვა სინტაქსის გამოყენება!.'
    },
     
}
export default data