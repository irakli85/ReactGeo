const data = {
    install : {
        text1 : 'Create React App არის კომფორტული გარემო React-ის შესასწავლად და ერთერთი გზა React-ში ახალი, ერთგვერდიანი აპლიკაციის შესაქმნელად.',
        text2 : 'ის ქმნის სამუშაო გარემოს ისე, რომ თქვენ შეგიძლიათ გამოიყენოთ JavaScript-ის უახლესი ფუნქციები, უზრუნველყოფს დეველოპერის სასიამოვნო გამოცდილებას React-თან მუშაობისას და ოპტიმიზაციას უკეთებს თქვენს აპლიკაციას. თქვენს კომპიუტერში უნდა გქონდეთ  დაინსტალირებული  ',
        text3 : ' Node >= 14.0.0 და npm >= 5.6.',
        text4 : ' პროექტის შესაქმნელად, ტერმინალში გაუშვით შემდეგი ბრძანებები:',
        text5 : 'პირველ სტრიქონზე npx არ გეგონოთ შეცდომა — ეს არის პაკეტების გაშვების ინსტრუმენტი, რომელიც npm-ში გაჩნდა 5.2+ ვერსიიდან.',
        text6 : 'Create React App არ ამუშავებს backend-ის და მონაცემთა ბაზების ლოგიკას; ის ქმნის frontend-იდან მონაცემების გამტარს, რომლებიც შემდეგ თქვენ შეგიძლიათ გამოიყენოთ ნებისმიერ backend ტექნოლოგიაში. Create React App იყენებს ',
        text7 : ' თუმცა ამ ეტაპზე თქვენ არ გჭირდებათ მათ შესახებ სიღრმისეული ცოდნა.',
        text8 : 'როდესაც თქვენი აპლიკაცია მზად იქნება,  ტერმინალში უნდა გაშვათ npm run build ბრძანება, რომელიც თქვენს პროექტში ახალ build საქაღალდეში შექმნის აპლიკაციის ოპტიმიზებულ კონსტრუქციას.'
    },
    article1 : {
        text1 : 'React-ის აპლიკაციის ყველაზე მცირე მაგალითი ასე გამოიყურება:',
        text2 : 'ვებ გვერდზე გამოჩნდება წარწერა:  “Hello, world!”',
        text3 : 'დააჭირეთ ზემოთ მოცემულ ბმულს კოდის ონლაინ რედაქტორის გასახსნელად. თავისუფლად შეიტანეთ კოდში ცვლილებები და ნახეთ, როგორ იმოქმედებს ისინი მიღებულ შედეგზე. ამ სახელმძღვანელოს გვერდების უმეტესობას ექნება მსგავსი რედაქტირებადი მაგალითები.',
        text4 : 'როგორ გამოვიყენოთ ეს სახელმძღვანელო',
        text5 : 'ამ სახელმძღვანელოში ჩვენ განვიხილავთ React-ის აპლიკაციების სამშენებლო ბლოკებს: ელემენტებს და კომპონენტებს. მას შემდეგ რაც მათ დაეუფლებით,  შეგეძლებათ შექმნათ რთული აპლიკაციები მცირე, მრავალჯერადი გამოყენების ნაწილებისგან.',
        text6 : 'ეს სახელმძღვანელო განკუთვნილია მათთვის, ვინც უპირატესობას ანიჭებს React-ის კონცეპციების სწავლას ეტაპობრივად, ნაბიჯ-ნაბიჯ.',
        text7 : 'სახელმძღვანელოს პირველ ნაწილში განხილულია React-ის ძირითადი კონცეფციები. სხვა განყოფილებების სია თქვენ შეგიძლიათ ნახოთ ნავიგაციის პანელში, მარჯვენა გვერდითა ზოლში.',
        text8 : 'სახელმძღვანელოს ყოველი ნაწილი ეფუძვნება წინა ნაწილებში გავლილ მასალას. თქვენ შეგიძლიათ გაეცნოთ React-ის მთავარ ნაწილს „ძირითადი კონცეფციების“  თავის გავლით და შემდეგ გაყვეთ თავებს იმ თანმიმდევრობით, როგორც ისინი არიან დალაგებული ნავიგაციის პანელში. მაგალითად, შემდეგი თავი არის  - "JSX-თან გაცნობა".',
        text9 : 'React – JavaScript-ის ბიბლიოთეკაა, ამიტომ ამ სახელმძღვანელოს გასავლელად თქვენ გჭირდებათ JavaScript ენის საბაზისო ცოდნა. თუკი თქვენ ვერ გძნობთ საკმარის თავდაჯერებულობას JavaScript-ში, გირჩევთ საკუთარი ცოდნის გასაახლებლად გაეცნოთ მითითებულ ბმულზე განთავსებულ '        
    },
    article2 : {
        text1 : 'განვიხილოთ ცვლადის გამოცხადების მაგალითი:',
        text2 : 'დამეთანხმებით, უცნაური სინტაქსია JavaScript-ისთვის - თითქოს არც სტრინგია და HTML-ის ფრაგმენტსაც წააგავს.',
        text3 : 'ეს არის JSX - JavaScript ენის გაფართოება. ჩვენ ვიყენებთ მას React-ში სამომხმარებლო ინტერფეისის (UI) შესაქმნელად.  JSX ძალიან წააგავს HTML მარქაფის ენას, თუმცა დამატებით ის ფლობს JavaScript-ის მთელ ძალას.  JSX-ის დახმარებით  იქმნება React-ის «ელემენტები». ',
        text4 : 'React-ის მთავარი პრინციპი მდგომარებს იმაში,  რომ რენდერინგის ლოგიკა განუყოფელია UI-ს სხვა ლოგიკებისგან, მაგალითად, როგორ იმართება event-ები, როგორ იცვლება დროში state და როგორ მზადდება მონაცემები ვებ გვერდზე გამოსატანად.',
        text5 : 'იმის ნაცვლად რომ მარქაფი და ფუნქციური ლოგიკა ხელოვნურად დავყოთ სხვადასხვა ფაილებში, React-ი უბრალოდ ანაწილებს პასაუხისმგებლობებს ურთიერთდაკავშირებული ელემენტების საშუალებით,  რომლებსაც ქვიათ «კომპონენტები». კომპონენტები შეიცავენ ერთდროულად მარქაფსაც და ლოგიკასაც.',
        text6 : 'ქვემოთ მოცემულ მაგალითში გამოვაცხადებთ name ცვლადს, რომელსაც შემდეგ ჩავსვამთ  JSX-ში, ფიგურული ფრჩხილების გამოყენებით:',
        text7 : 'JSX-ში ფიგურული ფრჩხილების შიგნით შესაძლებელია გამოვიყენოთ JavaScript-ში დასაშვები ნებისმიერი გამოსახულება. მაგალითად, 2 + 2, user.firstName და formatName(user).',
        text8 : 'ქვემოთ მოცემულ მაგალითში formatName(user) ფუნქციისგან მიღებულ შედეგს ვსვამთ  <h1> ელემენტში:',
        text9 : 'კომპილაციის შემდეგ ხდება ყველა JSX-გამოსახულების ისევე გამოძახება, როგორც ჩვეულებრივ JavaScript ფუნქციის, რომლის შედეგიც  - JavaScript ობიექტია. აქედან გამომდინარე JSX-ის გამოყენება შესაძლებელია if ინსტრუქციებში , for ციკლებში, შეგვიძლია ცვლადში შევინახოთ როგორც მნიშვნელობა, გადავცეთ ფუნქციას არგუმენტის სახით და ასევე დავაბრუნოთ ფუნქციიდან.',
        text10 : 'ელემენტის ატრიბუტებზე ტექსტური მნიშვნელობის მისანიჭებლად გამოიყენება ბრჭყალები:',
        text11 : 'თუკი ატრიბუტის მნიშვნელობაში გვჭირდება JavaScript-გამოსახულების მითითითება, ასეთ შემთხვევაში ვიყენებთ ფიგურულ ფრჩხილებს:',
        text12 : 'არ შეიძლება ბრჭყალების გამოყენება ფიგურული ფრჩხილების გარეთ, როცა ატრიბუტის მნიშვნელობად იყენებთ JavaScript-გამოსახულებებს. უნდა გამოვიყენოთ ცალცალკე -  ბრჭყალები (ტექსტური მნიშვნელობების დროს) ან ფიგურული ფრჩხილები (JavaScript-ის გამოსახულებების დროს), ოღონდ არა ერთად.',
        text13 : 'იმის გამო რომ JSX უფრო ახლოსაა  JavaScript-თან ვიდრე HTML-თან, React DOM-ი  ატრიბუტის სახელების შექმნისას, ჩვეულებრივი HTML ატრიბუტებისგან განსხვავებით, იყენებს camelCase ვარიანტს. მაგალითად,  ატრიბუტი class JSX-ში ხდება className , ხოლო tabindex - tabIndex.',
        text14 : 'ცარიელი, კონტენტის გარეშე ტეგი შეგვიძლია მაშინვე დავხუროთ /> გამოყენებით, ისევე როგორც  XML-ში:',
        text15 : 'JSX-ტეგები ასევე შესაძლებელია შეიცავდეს შვილობილ ელემენტებსაც:',
        text16 : 'მომხმარებლის მიერ შეყვანილი მონაცემები უსაფრთხოდ შეგვიძლია გამოვიყენოთ  JSX-ში:',
        text17 : 'ჩვეულებრივ  React DOM-ი გვერდს უვლის ყველა მონაცემს, რომელიც მოთავსებულია JSX-ში მანამდე, სანამ მოხდება რენდერი. ეს გამორიცხავს ყველა იმ მონაცემის მოხვედრას აპლიკაციაში, რაც არ იყო წინასწარ გაწერილი. ყველა მონაცემი საბოლოო ჯამში რენდერამდე გარდაიქმნება ტექსტურ ფორმატში, რაც გვეხმარება XSS (cross-site-scripting)  შეტევებისგან თავის არიდებაში.',
        text18 : 'Babel-ი აკომპილირებს JSX-ს  React.createElement() ფუნქციის გამოძახებით.',
        text19 : 'შემდეგი ორი მაგალითი ერთმანეთის ექვივალენტურია:',
        text20 : 'React.createElement() ფუნქცია ამოწმებს შეცდომებს კოდში და ამასთან ერთად, რაც მთავარია -  ქმნის მსგავს ობიექტს:',
        text21 : 'ამ ობიექტებს ქვიათ React-ელემენტები. შეიძლება ითქვას რომ, ისინი გამოსახავენ შედეგს, რომლის ნახვაც ჩვენ გვინდა ეკრანზე. React-ი კითხულობს ამ ობიექტებს და იყენებს მათ DOM-ის სტრუქტურის კონსტრუირებისთვის ან განახლებისთვის.'
    },
    article3 : {
        text1 : 'ელემენტები React აპლიკაციის ყველაზე პატარა სამშენებლო ბლოკებია.',
        text2 : 'ელემენტები აღწერენ იმას, თუ რისი ნახვაც გსურთ ეკრანზე:',
        text3 : 'ბრაუზერის DOM ელემენტებისგან განსხვავებით, React-ის ელემენტები უბრალო ობიექტებია და შესაბამისად მეხსიერების მცირე რესურს მოითხოვს მათი შექმნა. React DOM ზრუნავს ბრაუზერის DOM-ის განახლებაზე, რათა ის შეესაბამებოდეს React-ის ელემენტებს.',
        text4 : 'ნუ ავურევთ ერთმანეთში "ელემენტებს" და უფრო ფართოდ ცნობილ კონცეფციას - "კომპონენტებს". ელემენტები არის ის, რისგანაც შედგება კომპონენტები. ჩვენ განვიხილავთ კომპონენტებს ამ სახელმძღვანელოს მომდევნო ნაწილში.',
        text5 : 'მაგალითად, HTML ფაილში გვაქვს  <div> ტეგი:',
        text6 : 'React-ის აპლიკაციებისთვის ეს არის "ძირითადი", "root" DOM ​​კვანძი, რადგან React DOM მართვას მხოლოდ ამ კვანძში მიმდინარე ყველა პროცესს.',
        text7 : 'React-ის საშუალებით შექმნილ აპლიკაციებს ჩვეულებრივ აქვთ ერთი root DOM კვანძი. თუ ინტეგრაციას უკეთებთ React-ს უკვე არსებულ სხვა აპლიკაციაში, მაშინ თქვენ შეიძლება გქონდეთ იმდენი იზოლირებული root DOM კვანძი, რამდენიც გსურთ.',
        text8 : 'React-ელემენტის რენდერისთვის, ჯერ  DOM-ელემენტი  გადაეცემა  ReactDOM.createRoot() ფუნქციას, ხოლო შემდეგ React-ელემენტი  root.render() ფუნქციას:',
        text9 : 'ვებ-გვერდზე გამოვა ტექსტი  «Hello, world».',
        text10 : 'React-ის ელემენტები უცვლელია (immutable). მათი შექმნის შემდეგ, პირდაპირი გზით თქვენ ვეღარ შეცვლით მის შვილობილ ელემენტებს ან ატრიბუტებს. ელემენტი ჰგავს ერთ შეჩერებულ კადრს ფილმიდან: ის წარმოადგენს სტატიკურ UI-ს დროის გარკვეულ მომენტში.',
        text11 : 'ჯერჯერობით, React-ის იმ ცოდნით, რომელიც ამ ეტაპზე გვაქვს, UI-ს განახლების ერთადერთი გზა არის ახალი ელემენტის შექმნა და მისი გადაცემა root.render() ფუნქციაზე.',
        text12 : 'განვიხილოთ მაგალითი:',
        text13 : 'ამ მაგალითში root.render() ფუნქცია გამოიძახება ყოველ წამში  setInterval() ფუნქციის გამოყენებით.',
        text14 : 'პრაქტიკაში, უმრავლესობა React-აპლიკაციებში root.render() ფუნქცია გამოიძახება მხოლოდ ერთხელ. შემდეგში ჩვენ განვიხილავთ, თუ როგორ ხდება  UI-ს განახლება state-ის მეშვეობით.',
        text15 : 'React-ი ანახლებს მხოლოდ იმ ელემენტებს, რომელიც საჭიროა',
        text16 : 'React DOM-ი ადარებს მთავარ და მის შვილობილ ელემენტებს წინა ვერსიებს და DOM-ში შეაქვს მხოლოდ მინიმალური საჭირო განახლებები, DOM-ის სასურველ მდგომარეობამდე მისაყვანად.',
        text17 : 'ბოლო მაგალითის ბრაუზერში გადამოწმებით ადვილად შეგიძლიათ დარწმუნდეთ ამაში:',
        text18 : 'მიუხედავად იმისა, რომ ჩვენი შექმნილი ელემენტი შეიცავს აპლიკაციის მთელ  UI-ხეს, React DOM-ი ყოველ წამში ანახლებს ტექსტური კონტენტის მხოლოდ იმ ნაწილს , რომელიც იცვლება.'
    },
    article4 : {
        text1 : 'React აპლიკაციები აგებულია UI-ის იზოლირებული ნაწილებისგან, რომლებსაც ეწოდება კომპონენტები. React-ის კომპონენტი - ეს არის JavaScript-ის ფუნქცია, რომელშიც შეგვიძლია ვწეროთ მარქაფი. კომპონენტი შეიძლება იყოს ისეთივე პატარა, როგორც ღილაკი, ან ისეთივე დიდი, როგორც მთელი ვებ-გვერდი. მაგალითში მოცემულია  Gallery კომპონენტი, რომელიც შეიცავს სამ Profile კომპონენტს:',
        text2 : 'ტრადიციულად, ვებ გვერდების შექმნის დროს დეველოპერები ჯერ აკეთებდნენ კონტენტის მარქაფს, რომელსაც მერე JavaScript-ის საშუალებით აძლევდნენ ინტერაქტიულობას. React-ი ინტერაქტიულობას აყენებს პირველა ადგილზე.',
        text3 : 'export default სტანდარტული JavaScript მოდულების სინტაქსია. ის საშუალებას გაძლევთ ფაილში მონიშნოთ ძირითადი ფუნქცია, რათა მოგვიანებით შეძლოთ სხვა ფაილებში მისი იმპორტი.',
        text4 : 'function Profile() { } მეშვეობით  განსაზღვრულია JavaScript ფუნქცია სახელით Profile.',
        text5 : 'React კომპონენტები ჩვეულებრივი JavaScript ფუნქციებია, მაგრამ მათი სახელები უნდა დაიწყოს დიდი ასოებით, წინააღმდეგ შემთხვევაში ისინი არ იმუშავებენ!',
        text6 : 'Profile კომპონენტი აბრუნებს <img/> ტეგს, რომელსაც აქვს  src და alt ატრიბუტები. ტეგები იწერება იმავე სინტაქსით, როგორც HTML-ში, მაგრამ ის რეალურად JavaScript-ია! ამ სინტაქსს ეწოდება JSX და ის საშუალებას გაძლევთ ჩასვათ მარქაფი JavaScript-ში.',
        text7 : 'return-ის მნიშვნელობები უნდა დაიწეროს  ერთ ხაზზე, როგორც ამ კომპონენტში:',
        text8 : 'მაგრამ თუ თქვენი მარქაფი არ არის ერთ  ხაზზე, მაშინ return-ის შემდეგ ისინი უნდა მოთავსდნენ ფრჩხილებში:',
        text9 : 'ფრჩხილების გარეშე return-ის შემდეგ ყველა კოდი იგნორირებული იქნება!',
        text10 : 'ეხლა როცა თქვენ უკვე შექმენით  Profile კომპონენტი, შეგიძლიათ ის მოათავსოთ სხვა კომპონენტებში. მაგალითად, თქვენ შეგიძლიათ გააექსპორტოთ Gallery კომპონენტი, რომელიც იყენებს რამოდენიმე Profile კომპონენტს:',
        text11 : '<section> დაწერილია დაბალ რეგისტრში , ამიტომ React-მა იცის, რომ ჩვენ ამ შემთხვევაში ვიყენებთ HTML ტეგს.',
        text12 : '<Profile /> იწყება მაღალი რეგისტრის P ასოთი, ამიტომ, React-მა იცის, რომ ჩვენ ვიყენებთ Profile კომპონენტს.',
        text13 : 'Profile კომპონენტი თავად შეიცავს HTML-ს <img /> ტეგის სახით. საბოლოო ჯამში,  ბრაუზერი ხედავს ასეთ სტრუქტურას:',
        text14 : 'კომპონენტები ჩვეულებრივი JavaScript ფუნქციებია, ასე რომ თქვენ შეგიძლიათ შეინახოთ რამდენიმე კომპონენტი ერთ ფაილში. ეს მოსახერხებელია, მაშინ როდესაც კომპონენტები შედარებით მცირეა ან ერთმანეთთან მჭიდრო კავშირშია. თუ ერთ ფაილში ბევრი კომპონენტი დაგიგროვდათ, ყოველთვის შეგიძლიათ გადაიტანოთ ისინი ცალკე ფაილში.',
        text15 : 'რადგანაც Profile კომპონენტები მოთავსებული არიან Gallery კომპონენტის შიგნით  შეგვიძლია ვთქვათ, რომ Gallery არის მშობელი კომპონენტი, Profile კი შვილობილი კომპონენტი. ეს არის React-ის მაგიის ნაწილი: თქვენ შეგიძლიათ განსაზღვროთ კომპონენტი ერთხელ და შემდეგ გამოიყენოთ ის იმდენ ადგილას და იმდენჯერ, რამდენჯერაც გსურთ.',
        text16 : 'კომპონენტები შეიძლება შეიცავდეს  სხვა კომპონენტებს, თუმცა არ შეიძლება კომპონენტში სხვა კომპონენტის შექმნა:',
        text17 : 'ზემოთ მოყვანილი კოდის ფრაგმენტი ძალიან ნელია და იწვევს შეცდომებს. ამის ნაცვლად, განსაზღვრეთ ყველა კომპონენტი  ცალ-ცალკე, ზედა დონეზე:',
        text18 : 'React გაძლევთ საშუალებას შექმნათ კომპონენტები - მრავაჯერადად გამოყენებადი UI ელემენტები თქვენი აპლიკაციისთვის.',
        text19 : 'React-ის აპლიკაციაში ინტერფეისის თითოეული ნაწილი არის კომპონენტი.',
        text20 : 'React-ის კომპონენტები ჩვეულებრივი JavaScript ფუნქციებია, იმ განსხვავებით, რომ :',
        text21 : '1. მათი სახელები ყოველთვის დიდი ასოებით იწყება.',
        text22 : '2. ისინი აბრუნებენ JSX მარქაფს.'
    },
    article5 : {
        text1 : 'კომპონენტების მაგია მდგომარეობს მათი მრავალჯერადი  გამოყენების შესაძლებლობაში: თქვენ შეგიძლიათ შექმნათ კომპონენტები, რომლებიც შედგება სხვა კომპონენტებისგან. მაგრამ რაც უფრო და უფრო მეტ კომპონენტს ქმნით ერთ ფაილში, ხშირად უფრო მოსახერხებელია  მათი სხვადასხვა ფაილებად დაყოფა. ეს საშუალებას გაძლევთ მარტივად მისაგნები იყოს კომპონენტები და მათი ხელახლა გამოყენება სხვადასხვა  ადგილას.',
        text2 : 'ეს კომპონენტები მოთავსებულია მთავარ კომპონენტში, რომელსაც ქვია App.js.  ამ მაგალითში,  Create React App-ით შექმნილი თქვენი აპლიკაცია ცხოვრობს src/App.js ფაილში. React აპლიკაციის შექმნის მეთოდიდან გამომდინარე მთავარი კომპონენტი შეიძლება იყოს სხვა ფაილშიც.',
        text3 : 'როგორ უნდა მოვიქცეთ თუკი უკვე არსებული Gallery და Profile  კომპონენტების გამოყენება გვინდა სხვა ფაილში ან სულაც სხვა პროექტში?  ამისათვის კომპონენტები  უნდა გავიტანოთ ძირითადი ფაილიდან. ამით ისინი გახდებიან უფრო მოდულარულები და საშუალება გვექნება მრავალჯერადად გამოვიყენოთ სხვა ფაილებშიც. ამისათვის საჭიროა შემდეგი 3 ნაბიჯის გავლა:',
        text4 : 'შექმენით ახალი JS ფაილი, რომელშიც განვათავსებთ კომპონენტს.',
        text5 : 'დააექსპორტეთ კომპონენტი ამ ფაილიდან default ან named export-ის გამოყენებით.',
        text6 : 'დააიმპორტეთ კომპონენტი იმ ფაილში, სადაც გსურთ მისი გამოყენება default ან named import-ის შესაბამისი სინტაქსის გამოყენებით.',
        text7 : 'Profile და Gallery კომპონენტები გატანილია App.js-დან ახალ Gallery.js  ფაილში. ახლა თქვენ შეგიძლიათ შეცვალოთ App.js და დააიმპორტოთ Gallery კომპონენტი Gallery.js ფაილიდან.',
        text8 : 'ყურადღება მიაქციეთ, კომპონენტები როგორ არის დაყოფილი ორ ფაილში:',
        text9 : 'განსაზღვრულია Profile კომპონენტი, რომელიც გამოიყენება მხოლოდ ამ ფაილში და არ არის ექსპორტირებული.',
        text10 : 'ახდენს  Gallery კომპონენტის ექსპორტს, default export-ის გამოყენებით.',
        text11 : 'Gallery.js ფაილიდან დაიმპორტებულია Gallery კომპონენტი.',
        text12 : 'ახდენს ძირითადი  App კომპონენტის ექსპორტს, default export-ის გამოყენებით.',
        text13 : 'თქვენ შეიძლება შეგხვდეთ ფაილები, სადაც არ იქნება მითითებული .js  გაფართოება:',
        text14 : 'ორივე ჩანაწერი მუშაობს React-ში, თუმცა "./Gallery.js" უფრო ახლოს არის  კლასიკური ES მოდულების ჩაწერის სტილთან.',
        text15 : 'JavaScript-ში მნიშვნელობების ექსპორტის ორი ძირითადი გზა არსებობს: default და named ექსპორტი.  ჩვენს მაგალითებში გამოყენებულია მხოლოდ default ექსპორტი, მაგრამ თქვენ შეგიძლიათ გამოიყენოთ ერთი ან ორივე მათგანი ერთიდაიგივე ფაილში. ფაილში შეიძლება იყოს მხოლოდ ერთი default ექსპორტი, ხოლო named ექსპორტი იმდენი, რამდენიც გსურთ.',
        text16 : 'ის თუ რა გზით აექსპორტებთ კომპონენტს განსაზღვრავს იმ სინტაქსს , თუ როგორ შემოიტანთ მას სხვა ფაილში. შეუსაბამობის შემთხვევაში თქვენ მიიღებთ შეცდომას. ქვემოთ მოცემულ სქემა დაგეხმარებათ სინტაქსის სწორად შერჩევაში:',
        text17 : 'default იმპორტის შემთხვევაში, თქვენ შეგიძლიათ კომპონენტის სახელად გამოიყენოთ ნებისმიერი სახელი რაც მოგესურვებათ. მაგალითად, Button-ის ნაცვლად შეგიძლიათ დაწეროთ import Banana from "./Button.js" და თქვენ მაინც მიიღებთ იგივე კომპონენტს. ამის საპირისპიროდ, named იმპორტის დროს, სახელი ორივე ფაილში უნდა ემთხვეოდეს ერთმანეთს.',
        text18 : 'დეველოპერები ძირითადად იყენებენ default ექსპორტს მაშინ, თუ ფაილი მხოლოდ ერთ კომპონენტს შეიცავს, ხოლო  named ექსპორტს იყენებენ მაშინ, როცა ფაილში ბევრი კომპონენტი და მნიშვნელობაა. მიუხედავად იმისა, თუ რომელი კოდირების სტილს ანიჭებთ უპირატესობას, თქვენს შექმნილ კომპონენტებს, ფუნქციებს და მათ შემცველ ფაილებს ყოველთვის მიეცით აზრობრივად დატვირთული სახელები. უსახელო კომპონენტები შექმნა, მაგალითად  export default () => {}, არ არის  რეკომენდირებული.',
        text19 : 'როგორ უნდა მოვიქცეთ თუკი Gallery.js  ფაილიდან მხოლოდ Profile კომპონენტის შემოტანა გვსურს?  Gallery.js-ში  უკვე გამოყენებული გვაქვს default ექსპორტი და როგორც ზემოთ აღვნიშნეთ, ერთ ფაილში ორი default ექსპორტის გამოყენება  არ შეიძლება. ამ შემთხვევაში თქვენ შეგიძლიათ შექმნათ ახალი ფაილი და იქ გამოიყენოთ default ექსპორტი ან   დაამატოთ named ექსპორტი Profile კომპონენტს. ფაილში შეიძლება იყოს მხოლოდ ერთი default ექსპორტი, მაგრამ მას შეიძლება ჰქონდეს მრავალი named ექსპორტი!',
        text20 : 'default და named ექსპორტებთან დაკავშირებით გაუგებრობების თავიდან ასაცილებლად, პროექტზე მომუშავე გუნდის წევრები თანხმდებიან მათი გამოყენების ერთიან სტილზე. თქვენ შეგიძლიათ გამოიყენოთ ისინი თქვენი სურვილისამებრ.',
        text21 : 'პირველ რიგში , დააექსპორტეთ Profile კომპონენტი Gallery.js ფაილიდან named ექსპორტის გამოყენებით (default-ის  გარეშე):',
        text22 : 'შემდეგ, დააიმპორტეთ Profile კომპონენტი Gallery.js-დან App.js-ში named იმპორტის გამოყენებით (ფიგურულ ფრჩხილებში):',
        text23 : 'და ბოლოს,  თქვენ უკვე შეგიძლიათ გამოიყენოთ <Profile /> კომპონენტი App კომპონენტში:',
        text24 : 'Gallery.js უკვე შეიცავს ორ ექსპორტს: Gallery კომპონენტის default ექსპორტს და  Profile კომპონენტის named ექსპორტს, რომლებიც App.js-ში იმპორტირდება შესაბამისი სინტაქსით:',
        text25 : 'მოცემულ მაგალითში  ვიყენებთ default და named ექსპორტების ნაზავს:',
        text26 : 'ახდენს Profile კომპონენტის ექსპორტს named ექსპორტის გამოყენებით',
        text27 : 'ახდენს Gallery  კომპონენტის ექსპორტს , default ექსპორტის გამოყენებით',
        text28 : 'აიმპორტებს Profile კომპონენტს Gallery.js-დან, named იმპორტის გამოყენებით',
        text29 : 'აიმპორტებს Gallery კომპონენტს Gallery.js-დან, default იმპორტის გამოყენებით',
        text30 : 'ახდენს მთავარ App კომპონენტის default ექსპორტს',
        text31 : 'რა არის მთავარი კომპონენტი',
        text32 : 'როგორ ხდება კომპონენტების იმპორტი და ექსპორტი',
        text33 : 'როდის და როგორ გამოვიყენოთ default და named იმპორტი და ექსპორტი',
        text34 : 'როგორ მოვახდინოთ რამდენიმე კომპონენტის ექსპორტი ერთი და იგივე ფაილიდან'
    },
    article6 : {
        text1 : 'JSX არის JavaScript-ის სინტაქსის გაფართოება, რომელიც საშუალებას გაძლევთ ჩაწეროთ HTML-ის მსგავსი მარკირება JavaScript-ის ფაილში. მიუხედავად იმისა, რომ არსებობს კომპონენტების შექმნის სხვა გზებიც, React-ის დეველოპერების უმეტესობა უპირატესობას ანიჭებს JSX-ის ლაკონურობას და იყენებს მას.',
        text2 : 'ვები დაფუძვნებულია HTML, CSS და JavaScript-ზე. მრავალი წლის განმავლობაში, ვებ დეველოპერები კონტენტს ქმნიდნენ HTML-ში, დიზაინს CSS-ში და ხოლო ლოგიკას  JavaScript-ში - ხშირად ცალკ-ცალკე ფაილებში. კონტენტი მოთავსებული იყო HTML-ში, ხოლო ფუნქციონალი კონტენტისგან იზოლირებულად  JavaScript-ში:',
        text3 : 'მაგრამ დროთა განმავლობაში ვები სულ უფრო ინტერაქტიული ხდებოდა და ლოგიკა სულ უფრო მეტად განსაზღვრავდა კონტენტს. JavaScript გახდა პასუხისმგებელი HTML-ის სტრუქტურაზე. სწორედ ამიტომ React-ში ლოგიკა და მარკირება ერთად თანაცხოვრობენ ერთსა და იმავე ადგილას - კომპონენტებში.',
        text4 : 'ღილაკის ფუნქციონალური ლოგიკისა და მარკირების ერთად შენახვა უზრუნველყოფს მის სინქრონიულ ცვლილებას ყველგან  ყოველი რედაქტირებისას, ხოლო დეტალები, რომლებიც ერთმანეთთან არ არის დაკავშირებული, როგორიცაა მაგალითად, ღილაკის და ნავიგაციის პანელის მარკირება, იზოლირებულია ერთმანეთისგან, რაც უფრო უსაფრთხოს ხდის რომელიმე მათგანის დამოუკიდებლად რედაქტირებას.',
        text5 : 'თითოეული React კომპონენტი არის JavaScript-ის ფუნქცია, რომელიც შეიძლება შეიცავდეს  მარკირებას, რომელსაც React-ი შემდგომ აწვდის ბრაუზერს. React კომპონენტები იყენებენ სინტაქსურ გაფართოებას სახელწოდებით JSX. JSX ძალიან ჰგავს HTML-ს, მაგრამ უფრო მკაცრია და შეუძლია დინამიური ინფორმაციის გამოტანა.',
        text6 : 'JSX და React ორი განსხვავებული რამ არის. ისინი ხშირად გამოიყენება ერთად, მაგრამ შესაძლებელია მათი დამოუკიდებლად გამოყენებაც. JSX არის სინტაქსის გაფართოება, ხოლო React არის JavaScript ბიბლიოთეკა.',
        text7 : 'ეს იმიტომ ხდება, რომ JSX უფრო მკაცრია და აქვს HTML-ისგან განსხვავეული რამოდენიმე წესი. შეცდომის შეტყობინებები დაგეხმარებათ შეასწოროთ მარკირება.',
        text8 : 'უმეტეს შემთხვევაში, ეკრანზე გამოტანილი შეცდომის შეტყობინებები დაგეხმარებათ იპოვოთ პრობლემა. წაიკითხეთ ისინი ყურადღებით!',
        text9 : 'ბევრი ელემენტისგან შემდგარი კომპონენტებიდან ელემენტის დასაბრუნებლად, მოათავსეთ ისინი ერთი მშობელ ტეგში.',
        text10 : 'მაგალითად, შეგიძლიათ გამოიყენოთ <div> ტეგი:',
        text11 : '<div>-ის ნაცვლად შეგიძლიათ ასევე გამოიყენოთ ცარიელი ტეგის ფრაგმენტი <> და </> :',
        text12 : 'ფრაგმენტები საშუალებას გაძლევთ დააჯგუფოთ ელემენტები ბრაუზერის HTML ხეში ზედმეტი ელემენტების დამატების გარეშე.',
        text13 : 'რატომ არის საჭირო  JSX ტეგების მშობელ ელემენტში მოთავსება?',
        text14 : 'JSX ჰგავს HTML-ს, მაგრამ კომპილაციის შემდეგ ის გარდაიქმნება უბრალო JavaScript ობიექტებად. თქვენ არ შეგიძლიათ დააბრუნოთ ორი ობიექტი ფუნქციიდან, მათი მასივში მოთავსების გარეშე. ამით აიხსნება, თუ რატომ არ შეიძლება დააბრუნდეს ორი ან მეტი JSX ტეგი ერთ მშობელ ტეგში ან  ფრაგმენტში მოთავსების გარეშე.',
        text15 : 'JSX მოითხოვს ყველა ტეგების დახურვას: თვითდახურვადი ტეგები, როგორიცაა, მაგალითად <img>, JSX-ში უნდა ჩაიწეროს , როგორც <img />, ხოლო  <li>oranges უნდა ჩაიწეროს როგორც <li>oranges</li>.',
        text16 : 'ასე გამოიყურება  სურათი და სიის ელემენტების სწორად დახურული ტეგები:',
        text17 : 'JSX იქცევა JavaScript ობიექტად და JSX-ში დაწერილი ატრიბუტები ხდება JavaScript ობიექტების key მნიშვნელობები.  JavaScript-ს აქვს შეზღუდვები ცვლადის სახელებზე. მაგალითად, მათი სახელები არ შეიძლება შეიცავდეს ტირეებს, ასევე არ შეიძლება დარეზერვებული სიტყვების გამოყენება, მაგალითად, როგორიცაა class.',
        text18 : 'სწორედ ამიტომ, React-ში ბევრი HTML და SVG ატრიბუტი იწერება camelCase-ში. მაგალითად, stroke-width ატრიბუტის ნაცვლად უნდა გამოიყეენოთ strokeWidth. ვინაიდან class დარეზერვებული სიტყვაა, React-ში მის ნაცვლად გამოიყენება className:',
        text19 : 'თუ  შეგეშალათ, არ ინერვიულოთ - React გამოიტანს შეცდომის შეტყობინებას ბრაუზერის კონსოლში შესაძლო შესწორებით.',
        text20 : 'მხოლოდ aria - * და data - * ატრიბუტები იწერება ტირეებით, ისევე როგორც HTML-ში.',
        text21 : 'უკვე არსებულ HTML მარკირებიდან ყველა ატრიბუტის JSX სტილზე  გარდაქმნა შეიძლება დამღლელი იყოს. გირჩევთ გამოიყენოთ ',
        text22 : 'HTML-იდან და SVG-დან JSX-ზე კონვერტირებისთვის. კონვერტორები პრაქტიკაში ძალიან სასარგებლოა, მაგრამ აუცილებელია იმის ცოდნა, თუ როგორ მუშაობს JSX, რათა კომფორტულად წეროთ კოდი დამოუკიდებლად.',
        text23 : 'ახლა თქვენ უკვე იცით, რა არის JSX და როგორ გამოიყენოთ იგი კომპონენტებში:',
        text24 : 'React კომპონენტები აჯგუფებს  ლოგიკას და  მარკირებას ერთად, რადგან ისინი დაკავშირებულია.',
        text25 : 'JSX HTML-ის მსგავსია, რამდენიმე განსხვავებებით. საჭიროების შემთხვევაში შეგიძლიათ გამოიყენოთ კონვერტორი.',
        text26 : 'შეცდომის შეტყობინებები ხშირად მიგითითებთ სწორ ვარიანტს თქვენი მარკირების გამოსასწორებლად.',
    },
    article7 : {
        text1 : 'JSX საშუალებას გვაძლევს ჩავწეროთ HTML-ის მსგავსი მარკირება JavaScript-ის ფაილში და თან მოვათავსოთ  ლოგიკა და კონტენტი ერთსა და იმავე ადგილას. ზოგჯერ JSX მარკირების შიგნით საჭირო ხდება უფრო მეტი JavaScript ლოგიკის ან დინამიური მნიშვნელობების დამატება. ამ შემთხვევაში, შეგიძლიათ გამოიყენოთ ფიგურული ფრჩხილები  JSX-ში JavaScript-ის „ფანჯრის“ გასახსნელად.',
        text2 : 'JSX ატრიბუტზე სტინგული მნიშვნელობის გადასაცემად გამოიყენება ერთმაგი ან ორმაგი ბრჭყალები:',
        text3 : 'ამ მაგალითში  "https://i.imgur.com/7vQD0fPs.jpg" და "Gregorio Y. Zara" შესაბამის ატრიბუტებს სტრინგის სახით გადაიცემა.',
        text4 : 'იმ შემთხვევაში თუ დინამიური მნიშვნელობების გადაცემა გინდათ , მაგალითად  src ან alt ატრიბუტებისთვის, თქვენ შეგიძლიათ ბრჭყალები  " "  ჩაანაცვლოთ ფიგურული ფრჩხილებით { } :',
        text5 : 'მიაქციეთ ყურადღება  className="avatar" და src={avatar} ჩანაწერებს შორის განსხვავებას.  პირველ შემთხვევაში className="avatar"  განსაზღვრავს "avatar"  CSS კლასის სახელს სურათის კიდეების მოსამრგვალებლად, ხოლო მეორე შემთხვევაში, src ატრიბუტი მონაცემებს იღებს avatar ცვლადიდან. ფიგურული ფრჩხილები საშუალებას გაძლევთ იმუშაოთ JavaScript-ით  თქვენს მარკირებაში.',
        text6 : 'JSX არის JavaScript-ის ჩაწერის სპეციალური გზა. ეს ნიშნავს, რომ მასში JavaScript-ის გამოყენება შესაძლებელია — ფიგურული ფრჩხილების  { } მეშვეობით. ქვემოთ მოყვანილ მაგალითში ჯერ გამოაცხადებულია  name ცვლადი მეცნიერის სახელით, შემდეგ კი ფიგურული ფრჩხილების გამოყენებით  მოთავსებულია <h1> ტეგში:',
        text7 : 'თუკი შევცვლით name ცვლადის მნიშვნელობას "Gregorio Y. Zara"-დან "Hedy Lamarr"-ზე, ვნახავთ რომ, სათაურიც შეიცვლება.',
        text8 : 'ფიგურულ ფრჩხილებს შიგნით მუშაობს JavaScript-ის ნებისმიერი გამოსახულება, მათ შორის ფუნქციის გამოძახებაც, მაგალითად როგორიცაა ფუნქცია formatDate():',
        text9 : 'თქვენ შეგიძლიათ JSX-ში გამოიყენოთ ფიგურული ფრჩხილები  მხოლოდ ორი გზით:',
        text10 : "1.	როგორც ტექსტი პირდაპირ JSX ტეგის შიგნით: <h1>{name}'s To Do List</h1> იმუშავებს, მაგრამ <{tag}>Gregorio Y. Zara's To Do List</{tag}> არა.",
        text11 : '2. როგორც ატრიბუტები  =  ტოლობის ნიშნის შემდეგ: src={avatar} წაიკითხავს avatar ცვლადის მნიშვნელობას, მაგრამ src="{avatar}" სტრინგის სახით მოგვცემს  "{avatar}".',
        text12 : 'სტრინგების, რიცხვების და სხვა JavaScript მნიშვნელობების გარდა, JSX-ში ობიექტების გადაცემაც კი შეგიძლიათ. ობიექტები ასევე მოთავსებულია ფიგურულ ფრჩხილებში, მაგალითად { name: "Hedy Lamarr", inventions: 5 }. ამიტომ, JS ობიექტის JSX-ში გამოსაყენებლად, თქვენ უნდა მოათავსოთ ობიექტი კიდევ ერთ ფიგურულ ფრჩხილებში: person={{ name: "Hedy Lamarr", inventions: 5 }}.',
        text13 : 'ამის მაგალითია  inline CSS სტილები JSX-ში. React არ საჭიროებს  inline სტილების გამოყენებას (CSS კლასები მშვენივრად მუშაობს უმეტეს შემთხვევაში). მაგრამ როდესაც გვჭირდება inline სტილი,  style ატრიბუტს უნდა გადავცეთ ისინი ობიექტის სახით:',
        text14 : 'სცადეთ და შეცვალეთ backgroundColor-ის და color-ის  მნიშვნელობები.',
        text15 : 'ქვემოთ მოცემულ ჩანაწერში უფრო ნათლად ჩანს JSX-ის და ობიექტის ფიგურული ფრჩხილები:',
        text16 : 'შემდეგ ჯერზე, როცა შეგხვდებათ ორმაგი ფიგურული ფრჩხილები     {{  }}  JSX-ში, იცოდეთ, რომ ეს სხვა არაფერია, თუ არა ობიექტი JSX ფიგურულ ფრჩხილებს შიგნით!',
        text17 : "Inline სტილებში თვისებები იწერება camelCase-ში. მაგალითად, HTML <ul style='background-color: black'>, JSX-ში დაიწერება როგორც <ul style={{ backgroundColor: 'black' }}> .",
        text18 : 'თქვენ შეგიძლიათ მოათავსოთ რამდენიმე მნიშვნელობა ერთ ობიექტში და გამოიყენოთ ისინი JSX-ში ფიგურული ფრჩხილების  შიგნით:',
        text19 : 'ამ მაგალითში, person ობიექტი შეიცავს name სტრინგს და theme ობიექტს:',
        text20 : 'JSX როგორც შაბლონის ენა,  ძალიან მინიმალისტურია. ის საშუალებას გვაძლევს ერთ სივრცეში მოაწყოთ მონაცემები და ლოგიკა JavaScript-ის გამოყენებით.',
        text21 : 'ახლა თქვენ იცით თითქმის ყველაფერი JSX-ის შესახებ:',
        text22 : 'JSX-ში ატრიბუტებს მნიშვნელობები გადაეცემა ბრჭყალებში, როგორც სტინგები.',
        text23 : 'ფიგურული ფრჩხილები საშუალებას გაძლევთ შემოიტანოთ JavaScript ლოგიკა და ცვლადები თქვენს მარკირებაში.',
        text24 : 'ისინი მუშაობენ JSX ტეგის კონტენტში ან ატრიბუტებში = ტოლობის ნიშნის შემდეგ.',
        text25 : 'ორმაგი ფრჩხილები {{  }} არ არის სპეციალური სინტაქსი: ეს არის JavaScript ობიექტი, რომელიც მოთავსებულია JSX -ის ფიგურულ ფრჩხილებში'        
    },
     
}
export default data