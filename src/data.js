const data = {
    install : {
        text1 : 'Create React App არის კომფორტული გარემო React-ის შესასწავლად და ერთერთი გზა React-ში ახალი, ერთგვერდიანი აპლიკაციის შესაქმნელად.',
        text2 : 'ის ქმნის სამუშაო გარემოს ისე, რომ თქვენ შეგიძლიათ გამოიყენოთ JavaScript-ის უახლესი ფუნქციები, უზრუნველყოფს დეველოპერის სასიამოვნო გამოცდილებას React-თან მუშაობისას და ოპტიმიზაციას უკეთებს თქვენს აპლიკაციას. თქვენს კომპიუტერში უნდა გქონდეთ  დაინსტალირებული  ',
        text3 : ' Node >= 14.0.0 და npm >= 5.6.',
        text4 : ' პროექტის შესაქმნელად, ტერმინალში გაუშვით შემდეგი ბრძანებები:',
        text5 : 'პირველ სტრიქონზე npx არ გეგონოთ შეცდომა — ეს არის პაკეტების გაშვების ინსტრუმენტი, რომელიც npm-ში გაჩნდა 5.2+ ვერსიიდან.',
        text6 : 'Create React App არ ამუშავებს backend-ის და მონაცემთა ბაზების ლოგიკას; ის ქმნის frontend-იდან მონაცემების გამტარს, რომლებიც შემდეგ თქვენ შეგიძლიათ გამოიყენოთ ნებისმიერ backend ტექნოლოგიაში. Create React App იყენებს ',
        text7 : ' თუმცა ამ ეტაპზე თქვენ არ გჭირდებათ მათ შესახებ სიღრმისეული ცოდნა.',
        text8 : 'როდესაც თქვენი აპლიკაცია მზად იქნება,  ტერმინალში უნდა გაშვათ npm run build ბრძანება, რომელიც თქვენს პროექტში ახალ build საქაღალდეში შექმნის აპლიკაციის ოპტიმიზებულ კონსტრუქციას.'
    },
    article1 : {
        text1 : 'React-ის აპლიკაციის ყველაზე მცირე მაგალითი ასე გამოიყურება:',
        text2 : 'ვებ გვერდზე გამოჩნდება წარწერა:  “Hello, world!”',
        text3 : 'დააჭირეთ ზემოთ მოცემულ ბმულს კოდის ონლაინ რედაქტორის გასახსნელად. თავისუფლად შეიტანეთ კოდში ცვლილებები და ნახეთ, როგორ იმოქმედებს ისინი მიღებულ შედეგზე. ამ სახელმძღვანელოს გვერდების უმეტესობას ექნება მსგავსი რედაქტირებადი მაგალითები.',
        text4 : 'როგორ გამოვიყენოთ ეს სახელმძღვანელო',
        text5 : 'ამ სახელმძღვანელოში ჩვენ განვიხილავთ React-ის აპლიკაციების სამშენებლო ბლოკებს: ელემენტებს და კომპონენტებს. მას შემდეგ რაც მათ დაეუფლებით,  შეგეძლებათ შექმნათ რთული აპლიკაციები მცირე, მრავალჯერადი გამოყენების ნაწილებისგან.',
        text6 : 'ეს სახელმძღვანელო განკუთვნილია მათთვის, ვინც უპირატესობას ანიჭებს React-ის კონცეპციების სწავლას ეტაპობრივად, ნაბიჯ-ნაბიჯ.',
        text7 : 'სახელმძღვანელოს პირველ ნაწილში განხილულია React-ის ძირითადი კონცეფციები. სხვა განყოფილებების სია თქვენ შეგიძლიათ ნახოთ ნავიგაციის პანელში, მარჯვენა გვერდითა ზოლში.',
        text8 : 'სახელმძღვანელოს ყოველი ნაწილი ეფუძვნება წინა ნაწილებში გავლილ მასალას. თქვენ შეგიძლიათ გაეცნოთ React-ის მთავარ ნაწილს „ძირითადი კონცეფციების“  თავის გავლით და შემდეგ გაყვეთ თავებს იმ თანმიმდევრობით, როგორც ისინი არიან დალაგებული ნავიგაციის პანელში. მაგალითად, შემდეგი თავი არის  - "JSX-თან გაცნობა".',
        text9 : 'React – JavaScript-ის ბიბლიოთეკაა, ამიტომ ამ სახელმძღვანელოს გასავლელად თქვენ გჭირდებათ JavaScript ენის საბაზისო ცოდნა. თუკი თქვენ ვერ გძნობთ საკმარის თავდაჯერებულობას JavaScript-ში, გირჩევთ საკუთარი ცოდნის გასაახლებლად გაეცნოთ მითითებულ ბმულზე განთავსებულ '        
    },
    article2 : {
        text1 : 'განვიხილოთ ცვლადის გამოცხადების მაგალითი:',
        text2 : 'დამეთანხმებით, უცნაური სინტაქსია JavaScript-ისთვის - თითქოს არც სტრინგია და HTML-ის ფრაგმენტსაც წააგავს.',
        text3 : 'ეს არის JSX - JavaScript ენის გაფართოება. ჩვენ ვიყენებთ მას React-ში სამომხმარებლო ინტერფეისის (UI) შესაქმნელად.  JSX ძალიან წააგავს HTML მარქაფის ენას, თუმცა დამატებით ის ფლობს JavaScript-ის მთელ ძალას.  JSX-ის დახმარებით  იქმნება React-ის «ელემენტები». ',
        text4 : 'React-ის მთავარი პრინციპი მდგომარებს იმაში,  რომ რენდერინგის ლოგიკა განუყოფელია UI-ს სხვა ლოგიკებისგან, მაგალითად, როგორ იმართება event-ები, როგორ იცვლება დროში state და როგორ მზადდება მონაცემები ვებ გვერდზე გამოსატანად.',
        text5 : 'იმის ნაცვლად რომ მარქაფი და ფუნქციური ლოგიკა ხელოვნურად დავყოთ სხვადასხვა ფაილებში, React-ი უბრალოდ ანაწილებს პასაუხისმგებლობებს ურთიერთდაკავშირებული ელემენტების საშუალებით,  რომლებსაც ქვიათ «კომპონენტები». კომპონენტები შეიცავენ ერთდროულად მარქაფსაც და ლოგიკასაც.',
        text6 : 'ქვემოთ მოცემულ მაგალითში გამოვაცხადებთ name ცვლადს, რომელსაც შემდეგ ჩავსვამთ  JSX-ში, ფიგურული ფრჩხილების გამოყენებით:',
        text7 : 'JSX-ში ფიგურული ფრჩხილების შიგნით შესაძლებელია გამოვიყენოთ JavaScript-ში დასაშვები ნებისმიერი გამოსახულება. მაგალითად, 2 + 2, user.firstName და formatName(user).',
        text8 : 'ქვემოთ მოცემულ მაგალითში formatName(user) ფუნქციისგან მიღებულ შედეგს ვსვამთ  <h1> ელემენტში:',
        text9 : 'კომპილაციის შემდეგ ხდება ყველა JSX-გამოსახულების ისევე გამოძახება, როგორც ჩვეულებრივ JavaScript ფუნქციის, რომლის შედეგიც  - JavaScript ობიექტია. აქედან გამომდინარე JSX-ის გამოყენება შესაძლებელია if ინსტრუქციებში , for ციკლებში, შეგვიძლია ცვლადში შევინახოთ როგორც მნიშვნელობა, გადავცეთ ფუნქციას არგუმენტის სახით და ასევე დავაბრუნოთ ფუნქციიდან.',
        text10 : 'ელემენტის ატრიბუტებზე ტექსტური მნიშვნელობის მისანიჭებლად გამოიყენება ბრჭყალები:',
        text11 : 'თუკი ატრიბუტის მნიშვნელობაში გვჭირდება JavaScript-გამოსახულების მითითითება, ასეთ შემთხვევაში ვიყენებთ ფიგურულ ფრჩხილებს:',
        text12 : 'არ შეიძლება ბრჭყალების გამოყენება ფიგურული ფრჩხილების გარეთ, როცა ატრიბუტის მნიშვნელობად იყენებთ JavaScript-გამოსახულებებს. უნდა გამოვიყენოთ ცალცალკე -  ბრჭყალები (ტექსტური მნიშვნელობების დროს) ან ფიგურული ფრჩხილები (JavaScript-ის გამოსახულებების დროს), ოღონდ არა ერთად.',
        text13 : 'იმის გამო რომ JSX უფრო ახლოსაა  JavaScript-თან ვიდრე HTML-თან, React DOM-ი  ატრიბუტის სახელების შექმნისას, ჩვეულებრივი HTML ატრიბუტებისგან განსხვავებით, იყენებს camelCase ვარიანტს. მაგალითად,  ატრიბუტი class JSX-ში ხდება className , ხოლო tabindex - tabIndex.',
        text14 : 'ცარიელი, კონტენტის გარეშე ტეგი შეგვიძლია მაშინვე დავხუროთ /> გამოყენებით, ისევე როგორც  XML-ში:',
        text15 : 'JSX-ტეგები ასევე შესაძლებელია შეიცავდეს შვილობილ ელემენტებსაც:',
        text16 : 'მომხმარებლის მიერ შეყვანილი მონაცემები უსაფრთხოდ შეგვიძლია გამოვიყენოთ  JSX-ში:',
        text17 : 'ჩვეულებრივ  React DOM-ი გვერდს უვლის ყველა მონაცემს, რომელიც მოთავსებულია JSX-ში მანამდე, სანამ მოხდება რენდერი. ეს გამორიცხავს ყველა იმ მონაცემის მოხვედრას აპლიკაციაში, რაც არ იყო წინასწარ გაწერილი. ყველა მონაცემი საბოლოო ჯამში რენდერამდე გარდაიქმნება ტექსტურ ფორმატში, რაც გვეხმარება XSS (cross-site-scripting)  შეტევებისგან თავის არიდებაში.',
        text18 : 'Babel-ი აკომპილირებს JSX-ს  React.createElement() ფუნქციის გამოძახებით.',
        text19 : 'შემდეგი ორი მაგალითი ერთმანეთის ექვივალენტურია:',
        text20 : 'React.createElement() ფუნქცია ამოწმებს შეცდომებს კოდში და ამასთან ერთად, რაც მთავარია -  ქმნის მსგავს ობიექტს:',
        text21 : 'ამ ობიექტებს ქვიათ React-ელემენტები. შეიძლება ითქვას რომ, ისინი გამოსახავენ შედეგს, რომლის ნახვაც ჩვენ გვინდა ეკრანზე. React-ი კითხულობს ამ ობიექტებს და იყენებს მათ DOM-ის სტრუქტურის კონსტრუირებისთვის ან განახლებისთვის.'
    },
    article3 : {
        text1 : 'ელემენტები React აპლიკაციის ყველაზე პატარა სამშენებლო ბლოკებია.',
        text2 : 'ელემენტები აღწერენ იმას, თუ რისი ნახვაც გსურთ ეკრანზე:',
        text3 : 'ბრაუზერის DOM ელემენტებისგან განსხვავებით, React-ის ელემენტები უბრალო ობიექტებია და შესაბამისად მეხსიერების მცირე რესურს მოითხოვს მათი შექმნა. React DOM ზრუნავს ბრაუზერის DOM-ის განახლებაზე, რათა ის შეესაბამებოდეს React-ის ელემენტებს.',
        text4 : 'ნუ ავურევთ ერთმანეთში "ელემენტებს" და უფრო ფართოდ ცნობილ კონცეფციას - "კომპონენტებს". ელემენტები არის ის, რისგანაც შედგება კომპონენტები. ჩვენ განვიხილავთ კომპონენტებს ამ სახელმძღვანელოს მომდევნო ნაწილში.',
        text5 : 'მაგალითად, HTML ფაილში გვაქვს  <div> ტეგი:',
        text6 : 'React-ის აპლიკაციებისთვის ეს არის "ძირითადი", "root" DOM ​​კვანძი, რადგან React DOM მართვას მხოლოდ ამ კვანძში მიმდინარე ყველა პროცესს.',
        text7 : 'React-ის საშუალებით შექმნილ აპლიკაციებს ჩვეულებრივ აქვთ ერთი root DOM კვანძი. თუ ინტეგრაციას უკეთებთ React-ს უკვე არსებულ სხვა აპლიკაციაში, მაშინ თქვენ შეიძლება გქონდეთ იმდენი იზოლირებული root DOM კვანძი, რამდენიც გსურთ.',
        text8 : 'React-ელემენტის რენდერისთვის, ჯერ  DOM-ელემენტი  გადაეცემა  ReactDOM.createRoot() ფუნქციას, ხოლო შემდეგ React-ელემენტი  root.render() ფუნქციას:',
        text9 : 'ვებ-გვერდზე გამოვა ტექსტი  «Hello, world».',
        text10 : 'React-ის ელემენტები უცვლელია (immutable). მათი შექმნის შემდეგ, პირდაპირი გზით თქვენ ვეღარ შეცვლით მის შვილობილ ელემენტებს ან ატრიბუტებს. ელემენტი ჰგავს ერთ შეჩერებულ კადრს ფილმიდან: ის წარმოადგენს სტატიკურ UI-ს დროის გარკვეულ მომენტში.',
        text11 : 'ჯერჯერობით, React-ის იმ ცოდნით, რომელიც ამ ეტაპზე გვაქვს, UI-ს განახლების ერთადერთი გზა არის ახალი ელემენტის შექმნა და მისი გადაცემა root.render() ფუნქციაზე.',
        text12 : 'განვიხილოთ მაგალითი:',
        text13 : 'ამ მაგალითში root.render() ფუნქცია გამოიძახება ყოველ წამში  setInterval() ფუნქციის გამოყენებით.',
        text14 : 'პრაქტიკაში, უმრავლესობა React-აპლიკაციებში root.render() ფუნქცია გამოიძახება მხოლოდ ერთხელ. შემდეგში ჩვენ განვიხილავთ, თუ როგორ ხდება  UI-ს განახლება state-ის მეშვეობით.',
        text15 : 'React-ი ანახლებს მხოლოდ იმ ელემენტებს, რომელიც საჭიროა',
        text16 : 'React DOM-ი ადარებს მთავარ და მის შვილობილ ელემენტებს წინა ვერსიებს და DOM-ში შეაქვს მხოლოდ მინიმალური საჭირო განახლებები, DOM-ის სასურველ მდგომარეობამდე მისაყვანად.',
        text17 : 'ბოლო მაგალითის ბრაუზერში გადამოწმებით ადვილად შეგიძლიათ დარწმუნდეთ ამაში:',
        text18 : 'მიუხედავად იმისა, რომ ჩვენი შექმნილი ელემენტი შეიცავს აპლიკაციის მთელ  UI-ხეს, React DOM-ი ყოველ წამში ანახლებს ტექსტური კონტენტის მხოლოდ იმ ნაწილს , რომელიც იცვლება.'
    },
    article4 : {
        text1 : 'React აპლიკაციები აგებულია UI-ის იზოლირებული ნაწილებისგან, რომლებსაც ეწოდება კომპონენტები. React-ის კომპონენტი - ეს არის JavaScript-ის ფუნქცია, რომელშიც შეგვიძლია ვწეროთ მარქაფი. კომპონენტი შეიძლება იყოს ისეთივე პატარა, როგორც ღილაკი, ან ისეთივე დიდი, როგორც მთელი ვებ-გვერდი. მაგალითში მოცემულია  Gallery კომპონენტი, რომელიც შეიცავს სამ Profile კომპონენტს:',
        text2 : 'ტრადიციულად, ვებ გვერდების შექმნის დროს დეველოპერები ჯერ აკეთებდნენ კონტენტის მარქაფს, რომელსაც მერე JavaScript-ის საშუალებით აძლევდნენ ინტერაქტიულობას. React-ი ინტერაქტიულობას აყენებს პირველა ადგილზე.',
        text3 : 'export default სტანდარტული JavaScript მოდულების სინტაქსია. ის საშუალებას გაძლევთ ფაილში მონიშნოთ ძირითადი ფუნქცია, რათა მოგვიანებით შეძლოთ სხვა ფაილებში მისი იმპორტი.',
        text4 : 'function Profile() { } მეშვეობით  განსაზღვრულია JavaScript ფუნქცია სახელით Profile.',
        text5 : 'React კომპონენტები ჩვეულებრივი JavaScript ფუნქციებია, მაგრამ მათი სახელები უნდა დაიწყოს დიდი ასოებით, წინააღმდეგ შემთხვევაში ისინი არ იმუშავებენ!',
        text6 : 'Profile კომპონენტი აბრუნებს <img/> ტეგს, რომელსაც აქვს  src და alt ატრიბუტები. ტეგები იწერება იმავე სინტაქსით, როგორც HTML-ში, მაგრამ ის რეალურად JavaScript-ია! ამ სინტაქსს ეწოდება JSX და ის საშუალებას გაძლევთ ჩასვათ მარქაფი JavaScript-ში.',
        text7 : 'return-ის მნიშვნელობები უნდა დაიწეროს  ერთ ხაზზე, როგორც ამ კომპონენტში:',
        text8 : 'მაგრამ თუ თქვენი მარქაფი არ არის ერთ  ხაზზე, მაშინ return-ის შემდეგ ისინი უნდა მოთავსდნენ ფრჩხილებში:',
        text9 : 'ფრჩხილების გარეშე return-ის შემდეგ ყველა კოდი იგნორირებული იქნება!',
        text10 : 'ეხლა როცა თქვენ უკვე შექმენით  Profile კომპონენტი, შეგიძლიათ ის მოათავსოთ სხვა კომპონენტებში. მაგალითად, თქვენ შეგიძლიათ გააექსპორტოთ Gallery კომპონენტი, რომელიც იყენებს რამოდენიმე Profile კომპონენტს:',
        text11 : '<section> დაწერილია დაბალ რეგისტრში , ამიტომ React-მა იცის, რომ ჩვენ ამ შემთხვევაში ვიყენებთ HTML ტეგს.',
        text12 : '<Profile /> იწყება მაღალი რეგისტრის P ასოთი, ამიტომ, React-მა იცის, რომ ჩვენ ვიყენებთ Profile კომპონენტს.',
        text13 : 'Profile კომპონენტი თავად შეიცავს HTML-ს <img /> ტეგის სახით. საბოლოო ჯამში,  ბრაუზერი ხედავს ასეთ სტრუქტურას:',
        text14 : 'კომპონენტები ჩვეულებრივი JavaScript ფუნქციებია, ასე რომ თქვენ შეგიძლიათ შეინახოთ რამდენიმე კომპონენტი ერთ ფაილში. ეს მოსახერხებელია, მაშინ როდესაც კომპონენტები შედარებით მცირეა ან ერთმანეთთან მჭიდრო კავშირშია. თუ ერთ ფაილში ბევრი კომპონენტი დაგიგროვდათ, ყოველთვის შეგიძლიათ გადაიტანოთ ისინი ცალკე ფაილში.',
        text15 : 'რადგანაც Profile კომპონენტები მოთავსებული არიან Gallery კომპონენტის შიგნით  შეგვიძლია ვთქვათ, რომ Gallery არის მშობელი კომპონენტი, Profile კი შვილობილი კომპონენტი. ეს არის React-ის მაგიის ნაწილი: თქვენ შეგიძლიათ განსაზღვროთ კომპონენტი ერთხელ და შემდეგ გამოიყენოთ ის იმდენ ადგილას და იმდენჯერ, რამდენჯერაც გსურთ.',
        text16 : 'კომპონენტები შეიძლება შეიცავდეს  სხვა კომპონენტებს, თუმცა არ შეიძლება კომპონენტში სხვა კომპონენტის შექმნა:',
        text17 : 'ზემოთ მოყვანილი კოდის ფრაგმენტი ძალიან ნელია და იწვევს შეცდომებს. ამის ნაცვლად, განსაზღვრეთ ყველა კომპონენტი  ცალ-ცალკე, ზედა დონეზე:',
        text18 : 'React გაძლევთ საშუალებას შექმნათ კომპონენტები - მრავაჯერადად გამოყენებადი UI ელემენტები თქვენი აპლიკაციისთვის.',
        text19 : 'React-ის აპლიკაციაში ინტერფეისის თითოეული ნაწილი არის კომპონენტი.',
        text20 : 'React-ის კომპონენტები ჩვეულებრივი JavaScript ფუნქციებია, იმ განსხვავებით, რომ :',
        text21 : '1. მათი სახელები ყოველთვის დიდი ასოებით იწყება.',
        text22 : '2. ისინი აბრუნებენ JSX მარქაფს.'
    },
    article5 : {
        text1 : 'კომპონენტების მაგია მდგომარეობს მათი მრავალჯერადი  გამოყენების შესაძლებლობაში: თქვენ შეგიძლიათ შექმნათ კომპონენტები, რომლებიც შედგება სხვა კომპონენტებისგან. მაგრამ რაც უფრო და უფრო მეტ კომპონენტს ქმნით ერთ ფაილში, ხშირად უფრო მოსახერხებელია  მათი სხვადასხვა ფაილებად დაყოფა. ეს საშუალებას გაძლევთ მარტივად მისაგნები იყოს კომპონენტები და მათი ხელახლა გამოყენება სხვადასხვა  ადგილას.',
        text2 : 'ეს კომპონენტები მოთავსებულია მთავარ კომპონენტში, რომელსაც ქვია App.js.  ამ მაგალითში,  Create React App-ით შექმნილი თქვენი აპლიკაცია ცხოვრობს src/App.js ფაილში. React აპლიკაციის შექმნის მეთოდიდან გამომდინარე მთავარი კომპონენტი შეიძლება იყოს სხვა ფაილშიც.',
        text3 : 'როგორ უნდა მოვიქცეთ თუკი უკვე არსებული Gallery და Profile  კომპონენტების გამოყენება გვინდა სხვა ფაილში ან სულაც სხვა პროექტში?  ამისათვის კომპონენტები  უნდა გავიტანოთ ძირითადი ფაილიდან. ამით ისინი გახდებიან უფრო მოდულარულები და საშუალება გვექნება მრავალჯერადად გამოვიყენოთ სხვა ფაილებშიც. ამისათვის საჭიროა შემდეგი 3 ნაბიჯის გავლა:',
        text4 : 'შექმენით ახალი JS ფაილი, რომელშიც განვათავსებთ კომპონენტს.',
        text5 : 'დააექსპორტეთ კომპონენტი ამ ფაილიდან default ან named export-ის გამოყენებით.',
        text6 : 'დააიმპორტეთ კომპონენტი იმ ფაილში, სადაც გსურთ მისი გამოყენება default ან named import-ის შესაბამისი სინტაქსის გამოყენებით.',
        text7 : 'Profile და Gallery კომპონენტები გატანილია App.js-დან ახალ Gallery.js  ფაილში. ახლა თქვენ შეგიძლიათ შეცვალოთ App.js და დააიმპორტოთ Gallery კომპონენტი Gallery.js ფაილიდან.',
        text8 : 'ყურადღება მიაქციეთ, კომპონენტები როგორ არის დაყოფილი ორ ფაილში:',
        text9 : 'განსაზღვრულია Profile კომპონენტი, რომელიც გამოიყენება მხოლოდ ამ ფაილში და არ არის ექსპორტირებული.',
        text10 : 'ახდენს  Gallery კომპონენტის ექსპორტს, default export-ის გამოყენებით.',
        text11 : 'Gallery.js ფაილიდან დაიმპორტებულია Gallery კომპონენტი.',
        text12 : 'ახდენს ძირითადი  App კომპონენტის ექსპორტს, default export-ის გამოყენებით.',
        text13 : 'თქვენ შეიძლება შეგხვდეთ ფაილები, სადაც არ იქნება მითითებული .js  გაფართოება:',
        text14 : 'ორივე ჩანაწერი მუშაობს React-ში, თუმცა "./Gallery.js" უფრო ახლოს არის  კლასიკური ES მოდულების ჩაწერის სტილთან.',
        text15 : 'JavaScript-ში მნიშვნელობების ექსპორტის ორი ძირითადი გზა არსებობს: default და named ექსპორტი.  ჩვენს მაგალითებში გამოყენებულია მხოლოდ default ექსპორტი, მაგრამ თქვენ შეგიძლიათ გამოიყენოთ ერთი ან ორივე მათგანი ერთიდაიგივე ფაილში. ფაილში შეიძლება იყოს მხოლოდ ერთი default ექსპორტი, ხოლო named ექსპორტი იმდენი, რამდენიც გსურთ.',
        text16 : 'ის თუ რა გზით აექსპორტებთ კომპონენტს განსაზღვრავს იმ სინტაქსს , თუ როგორ შემოიტანთ მას სხვა ფაილში. შეუსაბამობის შემთხვევაში თქვენ მიიღებთ შეცდომას. ქვემოთ მოცემულ სქემა დაგეხმარებათ სინტაქსის სწორად შერჩევაში:',
        text17 : 'default იმპორტის შემთხვევაში, თქვენ შეგიძლიათ კომპონენტის სახელად გამოიყენოთ ნებისმიერი სახელი რაც მოგესურვებათ. მაგალითად, Button-ის ნაცვლად შეგიძლიათ დაწეროთ import Banana from "./Button.js" და თქვენ მაინც მიიღებთ იგივე კომპონენტს. ამის საპირისპიროდ, named იმპორტის დროს, სახელი ორივე ფაილში უნდა ემთხვეოდეს ერთმანეთს.',
        text18 : 'დეველოპერები ძირითადად იყენებენ default ექსპორტს მაშინ, თუ ფაილი მხოლოდ ერთ კომპონენტს შეიცავს, ხოლო  named ექსპორტს იყენებენ მაშინ, როცა ფაილში ბევრი კომპონენტი და მნიშვნელობაა. მიუხედავად იმისა, თუ რომელი კოდირების სტილს ანიჭებთ უპირატესობას, თქვენს შექმნილ კომპონენტებს, ფუნქციებს და მათ შემცველ ფაილებს ყოველთვის მიეცით აზრობრივად დატვირთული სახელები. უსახელო კომპონენტები შექმნა, მაგალითად  export default () => {}, არ არის  რეკომენდირებული.',
        text19 : 'როგორ უნდა მოვიქცეთ თუკი Gallery.js  ფაილიდან მხოლოდ Profile კომპონენტის შემოტანა გვსურს?  Gallery.js-ში  უკვე გამოყენებული გვაქვს default ექსპორტი და როგორც ზემოთ აღვნიშნეთ, ერთ ფაილში ორი default ექსპორტის გამოყენება  არ შეიძლება. ამ შემთხვევაში თქვენ შეგიძლიათ შექმნათ ახალი ფაილი და იქ გამოიყენოთ default ექსპორტი ან   დაამატოთ named ექსპორტი Profile კომპონენტს. ფაილში შეიძლება იყოს მხოლოდ ერთი default ექსპორტი, მაგრამ მას შეიძლება ჰქონდეს მრავალი named ექსპორტი!',
        text20 : 'default და named ექსპორტებთან დაკავშირებით გაუგებრობების თავიდან ასაცილებლად, პროექტზე მომუშავე გუნდის წევრები თანხმდებიან მათი გამოყენების ერთიან სტილზე. თქვენ შეგიძლიათ გამოიყენოთ ისინი თქვენი სურვილისამებრ.',
        text21 : 'პირველ რიგში , დააექსპორტეთ Profile კომპონენტი Gallery.js ფაილიდან named ექსპორტის გამოყენებით (default-ის  გარეშე):',
        text22 : 'შემდეგ, დააიმპორტეთ Profile კომპონენტი Gallery.js-დან App.js-ში named იმპორტის გამოყენებით (ფიგურულ ფრჩხილებში):',
        text23 : 'და ბოლოს,  თქვენ უკვე შეგიძლიათ გამოიყენოთ <Profile /> კომპონენტი App კომპონენტში:',
        text24 : 'Gallery.js უკვე შეიცავს ორ ექსპორტს: Gallery კომპონენტის default ექსპორტს და  Profile კომპონენტის named ექსპორტს, რომლებიც App.js-ში იმპორტირდება შესაბამისი სინტაქსით:',
        text25 : 'მოცემულ მაგალითში  ვიყენებთ default და named ექსპორტების ნაზავს:',
        text26 : 'ახდენს Profile კომპონენტის ექსპორტს named ექსპორტის გამოყენებით',
        text27 : 'ახდენს Gallery  კომპონენტის ექსპორტს , default ექსპორტის გამოყენებით',
        text28 : 'აიმპორტებს Profile კომპონენტს Gallery.js-დან, named იმპორტის გამოყენებით',
        text29 : 'აიმპორტებს Gallery კომპონენტს Gallery.js-დან, default იმპორტის გამოყენებით',
        text30 : 'ახდენს მთავარ App კომპონენტის default ექსპორტს',
        text31 : 'რა არის მთავარი კომპონენტი',
        text32 : 'როგორ ხდება კომპონენტების იმპორტი და ექსპორტი',
        text33 : 'როდის და როგორ გამოვიყენოთ default და named იმპორტი და ექსპორტი',
        text34 : 'როგორ მოვახდინოთ რამდენიმე კომპონენტის ექსპორტი ერთი და იგივე ფაილიდან'
    } 
}
export default data